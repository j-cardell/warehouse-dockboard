/**
 * Warehouse Dock Board - Main Application
 */

// API Base URL
const API_BASE = '';

// Global State
const state = {
  doors: [],
  trailers: [],
  yardTrailers: [],
  yardSlots: [],
  carriers: []
};

let pollingInterval = null;
let editMode = false;
let fetchErrorShown = false;
let consecutiveErrors = 0;
let isPaused = false;
const MAX_CONSECUTIVE_ERRORS = 5;
const NORMAL_POLL_INTERVAL = 5000;
const ERROR_POLL_INTERVAL = 30000; // Slow down on errors

// Undo functionality
let lastAction = null; // { type: 'moveToDoor'|'moveToYard'|'moveToSlot', trailerId, from: { doorNum|slotNum }, to: { doorNum|slotNum }, timestamp }

// Bulk selection
let selectedTrailers = new Set(); // Set of selected trailer IDs
let lastClickedTrailer = null;
let isShiftPressed = false;

// Search functionality
let searchQuery = '';
let searchResults = [];

// Door Management API
async function updateDoor(doorId, data) { return apiCall(`/doors/${doorId}`, 'PUT', data); }
async function createDoor(data) { return apiCall('/doors', 'POST', data); }
async function deleteDoor(doorId) { return apiCall(`/doors/${doorId}`, 'DELETE'); }

// Door Drag and Drop (edit mode)
let draggedDoorId = null;

function setupDoorDragAndDrop(grid) {
  const doors = grid.querySelectorAll('.door-draggable');
  
  doors.forEach(door => {
    door.addEventListener('dragstart', (e) => {
      draggedDoorId = door.dataset.doorId;
      door.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', draggedDoorId);
    });
    
    door.addEventListener('dragend', () => {
      door.classList.remove('dragging');
      draggedDoorId = null;
      grid.querySelectorAll('.drag-over').forEach(d => d.classList.remove('drag-over'));
    });
    
    door.addEventListener('dragover', (e) => {
      e.preventDefault();
      if (draggedDoorId && draggedDoorId !== door.dataset.doorId) {
        door.classList.add('drag-over');
      }
    });
    
    door.addEventListener('dragleave', () => {
      door.classList.remove('drag-over');
    });
    
    door.addEventListener('drop', async (e) => {
      e.preventDefault();
      door.classList.remove('drag-over');
      
      const sourceId = e.dataTransfer.getData('text/plain');
      const targetId = door.dataset.doorId;
      
      if (!sourceId || sourceId === targetId) return;
      
      // Reorder doors locally
      const sourceIndex = state.doors.findIndex(d => d.id === sourceId);
      const targetIndex = state.doors.findIndex(d => d.id === targetId);
      
      if (sourceIndex === -1 || targetIndex === -1) return;
      
      // Get all door IDs in current order
      const currentDoors = [...state.doors].sort((a, b) => {
        if (a.order !== undefined && b.order !== undefined) return a.order - b.order;
        return a.number - b.number;
      });
      const doorIds = currentDoors.map(d => d.id);
      
      // Move source to position after target
      const sourcePos = doorIds.indexOf(sourceId);
      const targetPos = doorIds.indexOf(targetId);
      
      doorIds.splice(sourcePos, 1);  // Remove from old position
      doorIds.splice(targetPos, 0, sourceId);  // Insert at new position
      
      // Update server with new order
      try {
        showToast('Reordering doors...', 'info');
        await fetch(`${API_BASE}/api/doors/reorder`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ doorIds })
        });
        showToast('Door order saved', 'success');
        fetchState();  // Refresh state
      } catch (error) {
        showToast('Failed to reorder doors: ' + error.message, 'error');
      }
    });
  });
}

// Yard Slot Management API
async function moveToYardSlot(trailerId, slotId) { return apiCall('/move-to-yard-slot', 'POST', { trailerId, slotId }); }
async function moveFromYardSlot(trailerId) { return apiCall('/move-from-yard-slot', 'POST', { trailerId }); }
async function updateYardSlot(slotId, data) { return apiCall(`/yard-slots/${slotId}`, 'PUT', data); }
async function createYardSlot(data) { return apiCall('/yard-slots', 'POST', data); }
async function deleteYardSlot(slotId) { return apiCall(`/yard-slots/${slotId}`, 'DELETE'); }

// ============================================================================
// API Functions
// ============================================================================

async function apiCall(endpoint, method = 'GET', body = null) {
  const url = `/api${endpoint}`;
  const options = { method, headers: { 'Content-Type': 'application/json' } };
  if (body) options.body = JSON.stringify(body);

  const response = await fetch(url, options);
  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new Error(error.error || `HTTP ${response.status}`);
  }
  return response.json();
}

async function getState() { return apiCall('/state'); }
async function moveToDoor(trailerId, doorId) { return apiCall('/move-to-door', 'POST', { trailerId, doorId }); }
async function moveToYard(trailerId, doorId) { return apiCall('/move-to-yard', 'POST', { trailerId, doorId }); }
async function createTrailer(data) { return apiCall('/trailers', 'POST', data); }
async function deleteTrailer(id) { return apiCall(`/trailers/${id}`, 'DELETE'); }
async function updateTrailer(id, data) { return apiCall(`/trailers/${id}`, 'PUT', data); }
async function getHistory(search = '', limit = 50, offset = 0, dateFrom = '', dateTo = '') { 
  const params = new URLSearchParams({ search, limit, offset });
  if (dateFrom) params.append('dateFrom', dateFrom);
  if (dateTo) params.append('dateTo', dateTo);
  return apiCall(`/history?${params.toString()}`); 
}
async function getTrailerHistory(trailerId) {
  return apiCall(`/trailers/${trailerId}/history`);
}

// ============================================================================
// Undo Functionality
// ============================================================================

function recordLastAction(type, trailerId, from, to) {
  lastAction = {
    type,
    trailerId,
    from: { ...from },
    to: { ...to },
    timestamp: Date.now()
  };
  updateUndoButton();
}

async function undoLastAction() {
  if (!lastAction) {
    showToast('Nothing to undo', 'warning');
    return;
  }
  
  // Check if undo is within time limit (5 minutes)
  if (Date.now() - lastAction.timestamp > 5 * 60 * 1000) {
    showToast('Undo expired (too old)', 'warning');
    lastAction = null;
    updateUndoButton();
    return;
  }

  try {
    const { type, trailerId, from, to } = lastAction;
    
    // Check if trailer is still at the destination before attempting undo
    const trailer = state.trailers.find(t => t.id === trailerId) || 
                    state.yardTrailers.find(t => t.id === trailerId);
    if (!trailer) {
      showToast('Trailer no longer exists', 'error');
      lastAction = null;
      updateUndoButton();
      return;
    }
    
    // If the trailer has been moved somewhere else since, warn but still try to undo
    // (user might still want to move it back to the original location)
    let currentPos = getTrailerPosition(trailer);
    if (!positionsMatch(currentPos, to)) {
      console.log('Trailer moved since last action, but attempting undo anyway');
    }
    
    // Perform the undo - move back to 'from' position
    if (from.doorNum) {
      await moveToDoor(trailerId, from.doorNum);
      showToast(`Undo: Moved trailer back to Door ${from.doorNum}`, 'success');
    } else if (from.slotNum) {
      // Find the slot ID
      const slot = state.yardSlots.find(s => s.number === from.slotNum);
      if (slot) {
        await moveToYardSlot(trailerId, slot.id);
        showToast(`Undo: Moved trailer back to Yard Spot ${from.slotNum}`, 'success');
      } else {
        await moveToYard(trailerId);
        showToast(`Undo: Moved trailer back to yard`, 'success');
      }
    } else {
      await moveToYard(trailerId);
      showToast(`Undo: Moved trailer back to unassigned yard`, 'success');
    }
    
    lastAction = null;
    updateUndoButton();
    fetchState();
  } catch (error) {
    showToast('Undo failed: ' + error.message, 'error');
  }
}

function updateUndoButton() {
  const btn = document.getElementById('btn-undo');
  if (btn) {
    btn.disabled = !lastAction;
    btn.style.opacity = lastAction ? '1' : '0.5';
    btn.title = lastAction ? `Undo: ${getActionDescription(lastAction)}` : 'Nothing to undo';
  }
}

function getActionDescription(action) {
  let toStr = '';
  if (action.to.doorNum) toStr = `Door ${action.to.doorNum}`;
  else if (action.to.slotNum) toStr = `Yard ${action.to.slotNum}`;
  else toStr = 'Unassigned Yard';
  return `Last move to ${toStr}`;
}

function getTrailerPosition(trailer) {
  const pos = { doorNum: null, slotNum: null, unassigned: false };
  if (trailer.doorNumber) {
    pos.doorNum = trailer.doorNumber;
  } else if (trailer.yardSlotNumber) {
    pos.slotNum = trailer.yardSlotNumber;
  } else {
    pos.unassigned = true;
  }
  return pos;
}

function positionsMatch(pos1, pos2) {
  // Check if both are unassigned
  if (pos1.unassigned && pos2.unassigned) return true;
  // Check door numbers match
  if (pos1.doorNum !== pos2.doorNum) return false;
  // Check slot numbers match
  if (pos1.slotNum !== pos2.slotNum) return false;
  // If we're here and neither has a position defined, check unassigned flag
  if (!pos1.doorNum && !pos1.slotNum && !pos2.doorNum && !pos2.slotNum) {
    return pos1.unassigned === pos2.unassigned;
  }
  return true;
}

// ============================================================================
// Dwell Time Alerts
// ============================================================================

function getDwellTimeClass(createdAt) {
  if (!createdAt) return '';
  
  const created = new Date(createdAt).getTime();
  const now = Date.now();
  const hours = (now - created) / (1000 * 60 * 60);
  
  // 2+ hours = critical (flashing red)
  // 1+ hours = warning (flashing yellow)
  if (hours >= 2) return 'dwell-critical';
  if (hours >= 1) return 'dwell-warning';
  return '';
}

function getDwellTimeHours(createdAt) {
  if (!createdAt) return null;
  
  const created = new Date(createdAt).getTime();
  const now = Date.now();
  return Math.floor((now - created) / (1000 * 60 * 60));
}

function getDwellTimeMinutes(createdAt) {
  if (!createdAt) return null;
  
  const created = new Date(createdAt).getTime();
  const now = Date.now();
  const totalMinutes = Math.floor((now - created) / (1000 * 60));
  return totalMinutes % 60; // Minutes within the current hour
}

function formatDwellTime(createdAt) {
  const hours = getDwellTimeHours(createdAt);
  const minutes = getDwellTimeMinutes(createdAt);
  if (hours === null) return '';
  if (hours < 1) return `${minutes}m`;
  return `${hours}h ${minutes}m`;
  return `${hours}h`;
}

// ============================================================================
// Search Functionality
// ============================================================================

function performSearch(query) {
  searchQuery = query.toLowerCase().trim();
  
  if (!searchQuery) {
    searchResults = [];
    renderDoors();
    renderYardSlots();
    renderUnassignedYard();
    return;
  }
  
  searchResults = [];
  
  // Search in docked trailers (including customer and loadNumber)
  state.trailers.forEach(t => {
    if (t.number?.toLowerCase().includes(searchQuery) ||
        t.carrier?.toLowerCase().includes(searchQuery) ||
        t.customer?.toLowerCase().includes(searchQuery) ||
        t.loadNumber?.toLowerCase().includes(searchQuery) ||
        (t.doorNumber && `door ${t.doorNumber}`.includes(searchQuery))) {
      searchResults.push({ type: 'dock', trailer: t });
    }
  });
  
  // Search in yard slots (including customer and loadNumber)
  state.yardSlots.forEach(slot => {
    if (slot.trailerId) {
      const t = state.trailers.find(tr => tr.id === slot.trailerId) ||
                state.yardTrailers.find(tr => tr.id === slot.trailerId);
      if (t && (t.number?.toLowerCase().includes(searchQuery) ||
                t.carrier?.toLowerCase().includes(searchQuery) ||
                t.customer?.toLowerCase().includes(searchQuery) ||
                t.loadNumber?.toLowerCase().includes(searchQuery) ||
                `yard ${slot.number}`.includes(searchQuery))) {
        searchResults.push({ type: 'yard-slot', trailer: t, slot });
      }
    }
  });
  
  // Search in unassigned yard (including customer and loadNumber)
  state.yardTrailers.forEach(t => {
    if (t.number?.toLowerCase().includes(searchQuery) ||
        t.carrier?.toLowerCase().includes(searchQuery) ||
        t.customer?.toLowerCase().includes(searchQuery) ||
        t.loadNumber?.toLowerCase().includes(searchQuery)) {
      searchResults.push({ type: 'unassigned', trailer: t });
    }
  });
  
  renderDoors();
  renderYardSlots();
  renderUnassignedYard();
  
  // Show results toast
  const count = searchResults.length;
  if (count > 0) {
    showToast(`üîç Found ${count} result${count === 1 ? '' : 's'}`, count > 5 ? 'warning' : 'info');
  } else {
    showToast(`üîç No matches found`, 'warning');
  }
}

function clearSearch() {
  searchQuery = '';
  searchResults = [];
  const searchInput = document.getElementById('search-input');
  if (searchInput) searchInput.value = '';
  renderDoors();
  renderYardSlots();
  renderUnassignedYard();
}

function isTrailerInSearchResults(trailerId) {
  return searchResults.some(r => r.trailer.id === trailerId);
}

// ============================================================================
// Search Results Modal
// ============================================================================

function showSearchResultsModal() {
  if (!searchQuery || searchResults.length === 0) {
    showToast('No search results to show', 'warning');
    return;
  }
  
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.id = 'modal-search-results';
  
  const resultsList = searchResults.map(r => {
    const t = r.trailer;
    const dwellHours = getDwellTimeHours(t.createdAt);
    const dwellText = dwellHours !== null ? `${dwellHours}h` : '-';
    
    let locationText = '';
    if (r.type === 'dock') {
      locationText = t.doorNumber ? `Door ${t.doorNumber}` : 'Dock';
    } else if (r.type === 'yard-slot') {
      locationText = r.slot ? `Yard ${r.slot.number}` : 'Yard Slot';
    } else {
      locationText = 'Unassigned Yard';
    }
    
    return `
      <div class="search-result-item" data-trailer-id="${t.id}">
        <div class="search-result-main">
          <span class="search-carrier">${t.carrier}</span>
          ${t.customer ? `<span class="search-customer">(${t.customer})</span>` : ''}
        </div>
        <div class="search-result-details">
          <span class="search-detail" title="Trailer Number">üöõ ${t.number || '-'}</span>
          <span class="search-detail" title="Load Number">üì¶ ${t.loadNumber || '-'}</span>
          <span class="search-detail" title="Dwell Time">‚è±Ô∏è ${dwellText}</span>
          <span class="search-detail search-location" title="Location">üìç ${locationText}</span>
        </div>
        <div class="search-result-hint">Double-click to edit</div>
      </div>
    `;
  }).join('');
  
  modal.innerHTML = `
    <div class="modal-content modal-large">
      <div class="modal-header">
        <h3>üîç Search Results (${searchResults.length})</h3>
        <button class="close-modal">&times;</button>
      </div>
      <div class="modal-body">
        <div class="search-results-list">
          ${resultsList}
        </div>
      </div>
      <div class="modal-actions">
        <button class="btn btn-secondary close-modal">Close</button>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // Close handlers
  modal.querySelectorAll('.close-modal').forEach(btn => {
    btn.addEventListener('click', () => modal.remove());
  });
  
  // Double-click to edit handlers
  modal.querySelectorAll('.search-result-item').forEach(item => {
    item.addEventListener('dblclick', () => {
      const trailerId = item.dataset.trailerId;
      modal.remove();
      openTrailerEditModal(trailerId);
    });
  });
}

// ============================================================================
// Bulk Selection
// ============================================================================

function toggleTrailerSelection(trailerId, event) {
  const isSelected = selectedTrailers.has(trailerId);
  
  // Shift+Click for range selection
  if (isShiftPressed && lastClickedTrailer && !isSelected) {
    // Get all visible trailer IDs in order
    const allTrailers = getAllVisibleTrailerIds();
    const lastIndex = allTrailers.indexOf(lastClickedTrailer);
    const currentIndex = allTrailers.indexOf(trailerId);
    
    if (lastIndex !== -1 && currentIndex !== -1) {
      const start = Math.min(lastIndex, currentIndex);
      const end = Math.max(lastIndex, currentIndex);
      for (let i = start; i <= end; i++) {
        selectedTrailers.add(allTrailers[i]);
      }
    }
  } else if (event && isShiftPressed && isSelected) {
    // Shift+Click on already selected - remove from selection
    selectedTrailers.delete(trailerId);
  } else {
    // Normal toggle
    if (isSelected) {
      selectedTrailers.delete(trailerId);
    } else {
      selectedTrailers.add(trailerId);
    }
  }
  
  lastClickedTrailer = trailerId;
  updateSelectionUI();
  updateBulkActionUI();
}

function getAllVisibleTrailerIds() {
  const ids = [];
  // Docked trailers
  state.trailers.filter(t => t.doorNumber).forEach(t => ids.push(t.id));
  // Yard slots
  state.yardSlots.filter(s => s.trailerId).forEach(s => {
    if (!ids.includes(s.trailerId)) ids.push(s.trailerId);
  });
  // Unassigned
  state.yardTrailers.forEach(t => ids.push(t.id));
  return ids;
}

function clearSelection() {
  selectedTrailers.clear();
  lastClickedTrailer = null;
  updateSelectionUI();
  updateBulkActionUI();
}

function updateSelectionUI() {
  // Add/remove 'selected' class from all trailer cards/elements
  document.querySelectorAll('.trailer-card, .yard-trailer, .yard-slot.occupied').forEach(el => {
    const trailerId = el.dataset.trailerId;
    if (selectedTrailers.has(trailerId)) {
      el.classList.add('selected');
    } else {
      el.classList.remove('selected');
    }
  });
}

function updateBulkActionUI() {
  const count = selectedTrailers.size;
  const bulkBar = document.getElementById('bulk-selection-bar');
  const bulkInfo = document.getElementById('bulk-selection-info');
  const bulkMoveToYard = document.getElementById('btn-bulk-move-to-yard');
  
  // Only show bar when 2+ items selected
  if (bulkBar) {
    if (count >= 2) {
      bulkBar.classList.remove('hidden');
    } else {
      bulkBar.classList.add('hidden');
    }
  }
  
  if (bulkInfo) {
    bulkInfo.textContent = `${count} selected`;
  }
  
  if (bulkMoveToYard) {
    bulkMoveToYard.disabled = count === 0;
  }
}

async function bulkMoveToYard() {
  if (selectedTrailers.size === 0) {
    showToast('No trailers selected', 'warning');
    return;
  }
  
  const ids = Array.from(selectedTrailers);
  showToast(`Moving ${ids.length} trailers to yard...`, 'info');
  
  let successCount = 0;
  let failCount = 0;
  
  for (const trailerId of ids) {
    try {
      const trailer = state.trailers.find(t => t.id === trailerId);
      if (trailer && trailer.doorNumber) {
        await moveToYard(trailerId, trailer.doorNumber);
        successCount++;
      }
    } catch (error) {
      failCount++;
    }
  }
  
  if (successCount > 0) {
    showToast(`‚úÖ Moved ${successCount} trailer${successCount === 1 ? '' : 's'} to yard`, 'success');
  }
  if (failCount > 0) {
    showToast(`‚ùå Failed to move ${failCount} trailer${failCount === 1 ? '' : 's'}`, 'error');
  }
  
  clearSelection();
  fetchState();
}

// ============================================================================
// Trailer Timeline
// ============================================================================

async function loadTrailerTimeline(trailerId) {
  const container = document.getElementById('trailer-timeline');
  if (!container) return;
  
  container.innerHTML = '<div class="timeline-loading">Loading history...</div>';
  
  try {
    // Try to fetch timeline from history API
    const history = await getHistory(trailerId, 20);
    
    // Include all trailer-related events
    const timelineEvents = (history.entries || []).filter(e => 
      e.action?.includes('TRAILER') || 
      e.action?.includes('MOVED')
    );
    
    if (timelineEvents.length === 0) {
      // Create a simple timeline from what we know
      const trailer = state.trailers.find(t => t.id === trailerId) ||
                      state.yardTrailers.find(t => t.id === trailerId);
      if (trailer) {
        container.innerHTML = renderSimpleTimeline([{
          action: 'Created',
          timestamp: trailer.createdAt,
          location: trailer.doorNumber ? `Door ${trailer.doorNumber}` : 
                   trailer.yardSlotNumber ? `Yard ${trailer.yardSlotNumber}` : 'Unassigned Yard',
          status: trailer.status
        }]);
      } else {
        container.innerHTML = '<div class="timeline-empty">No timeline data available</div>';
      }
      return;
    }
    
    // History already comes newest first, keep that order for display (most recent at top)
    container.innerHTML = renderTimeline(timelineEvents);
  } catch (error) {
    // Fallback to simple timeline
    const trailer = state.trailers.find(t => t.id === trailerId) ||
                    state.yardTrailers.find(t => t.id === trailerId);
    if (trailer) {
      container.innerHTML = renderSimpleTimeline([{
        action: 'Created',
        timestamp: trailer.createdAt,
        location: trailer.doorNumber ? `Door ${trailer.doorNumber}` : 
                 trailer.yardSlotNumber ? `Yard ${trailer.yardSlotNumber}` : 'Unassigned Yard',
        status: trailer.status
      }]);
    } else {
      container.innerHTML = '<div class="timeline-empty">Unable to load timeline</div>';
    }
  }
}

function renderTimeline(events) {
  const fieldLabels = {
    number: 'trailer number',
    loadNumber: 'load number',
    customer: 'customer',
    carrier: 'carrier',
    contents: 'notes',
    status: 'status'
  };
  
  return `
    <div class="timeline">
      ${events.map((e, i) => {
        // Format location info
        let locationText = '';
        if (e.action?.includes('DOOR')) {
          locationText = `Door ${e.doorNumber}`;
        } else if (e.action?.includes('YARD_SLOT')) {
          locationText = e.toLocation || `Yard Slot ${e.slotId?.replace('yard-', '') || '?'}`;
        } else if (e.action?.includes('YARD')) {
          locationText = 'Unassigned Yard';
        }
        
        // Build action description
        let actionDesc = e.action?.replace(/_/g, ' ') || 'Unknown';
        
        // Handle different event types
        if (e.action === 'TRAILER_CREATED') {
          actionDesc = 'Created';
          if (locationText) actionDesc += ` at ${locationText}`;
          if (e.status) actionDesc += ` (${e.status})`;
        }
        else if (e.action?.includes('MOVED')) {
          if (e.previousLocation && locationText) {
            actionDesc = `Moved from ${e.previousLocation} to ${locationText}`;
          } else if (locationText) {
            actionDesc = `Moved to ${locationText}`;
          }
        }
        else if (e.action === 'TRAILER_UPDATED') {
          // Try changes array first (new format), fall back to updates (old format)
          if (e.changes?.length > 0) {
            const change = e.changes[0];
            const label = fieldLabels[change.field] || change.field;
            if (!change.from) {
              actionDesc = `Added ${label}: ${change.to}`;
            } else if (!change.to) {
              actionDesc = `Removed ${label}`;
            } else {
              actionDesc = `Changed ${label}: ${change.from} ‚Üí ${change.to}`;
            }
          } else if (e.updates) {
            // Old format - list what was updated
            const updatedFields = Object.keys(e.updates).filter(k => k !== 'carrier' && k !== 'status');
            if (updatedFields.length > 0) {
              const fields = updatedFields.map(f => fieldLabels[f] || f).join(', ');
              actionDesc = `Updated ${fields}`;
            } else if (e.updates.status) {
              actionDesc = `Marked ${e.updates.status}`;
            } else {
              actionDesc = 'Updated';
            }
          }
        }
        else if (e.action === 'TRAILER_LOADED') {
          actionDesc = 'Marked loaded';
        }
        else if (e.action === 'TRAILER_EMPTY') {
          actionDesc = 'Marked empty';
        }
        else if (e.action === 'TRAILER_DELETED') {
          actionDesc = 'Deleted';
        }
        
        const isCurrent = i === 0; // Most recent is first (at top)
        
        // Get color coding for event type
        let eventClass = '';
        if (e.action?.includes('CREATED')) eventClass = 'created';
        else if (e.action?.includes('DELETED')) eventClass = 'deleted';
        else if (e.action?.includes('MOVED')) eventClass = 'moved';
        else if (e.action?.includes('UPDATED') || e.action?.includes('LOADED') || e.action?.includes('EMPTY')) eventClass = 'updated';
        
        // Build location display - inline compact format using history-location classes
        let locationDisplay = '';
        if (e.action?.includes('MOVED') && e.previousLocation && locationText) {
          locationDisplay = `
            <span class="timeline-location-inline">
              <span class="tl-from">${e.previousLocation}</span>
              <span class="tl-arrow">‚Üí</span>
              <span class="tl-to">${locationText}</span>
            </span>
          `;
        } else if (locationText) {
          locationDisplay = `<span class="timeline-location-inline">${locationText}</span>`;
        }
        
        return `
        <div class="timeline-item ${isCurrent ? 'timeline-current' : ''} ${eventClass}">
          <div class="timeline-dot ${isCurrent ? 'current' : ''} ${eventClass}"></div>
          <div class="timeline-content">
            <div class="timeline-meta">
              <span class="timeline-action">${actionDesc}</span>
              ${locationDisplay}
            </div>
            <span class="timeline-time">${new Date(e.timestamp).toLocaleString()}</span>
          </div>
        </div>
        `;
      }).join('')}
    </div>
  `;
}

function renderSimpleTimeline(events) {
  return `
    <div class="timeline">
      ${events.map((e, i) => `
        <div class="timeline-item ${i === 0 ? 'timeline-current' : ''}">
          <div class="timeline-dot"></div>
          <div class="timeline-content">
            <div class="timeline-action">${e.action}</div>
            <div class="timeline-location">üìç ${e.location || 'Unknown'}</div>
            <div class="timeline-status">Status: ${e.status === 'loaded' ? 'üì¶ Loaded' : 'üì≠ Empty'}</div>
            <div class="timeline-time">${new Date(e.timestamp).toLocaleString()}</div>
          </div>
        </div>
      `).join('')}
    </div>
  `;
}

// ============================================================================
// Analytics Dashboard
// ============================================================================

async function showAnalyticsModal() {
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.id = 'modal-analytics';
  
  modal.innerHTML = `
    <div class="modal-content modal-large">
      <div class="modal-header">
        <h3>üìä Dwell Time Analytics</h3>
        <button class="close-modal">&times;</button>
      </div>
      <div class="modal-body">
        <div class="analytics-tabs">
          <button class="analytics-tab active" data-view="dwell">Avg Dwell Time</button>
          <button class="analytics-tab" data-view="violations">2+ Hour Violations</button>
          <button class="analytics-tab" data-view="patterns">Position Patterns</button>
        </div>
        <div class="analytics-subtabs" id="dwell-tabs">
          <button class="analytics-subtab active" data-period="day">Daily (7 days)</button>
          <button class="analytics-subtab" data-period="week">Weekly (4 weeks)</button>
          <button class="analytics-subtab" data-period="month">Monthly (3 months)</button>
        </div>
        <div class="analytics-chart-container" id="chart-container">
          <canvas id="analytics-chart" width="800" height="400"></canvas>
        </div>
        <div class="analytics-violations hidden" id="violations-container">
          <div class="violations-header">
            <h4>Current Trailers Exceeding 2 Hours</h4>
            <span class="violations-count" id="current-violation-count">0</span>
          </div>
          <div class="violations-list" id="violations-list">
            <div class="violations-loading">Loading...</div>
          </div>
          <div class="violations-history">
            <h4>Historical Violation Counts</h4>
            <div id="violations-chart-container">
              <canvas id="violations-chart" width="800" height="300"></canvas>
            </div>
          </div>
        </div>
        <div class="analytics-patterns hidden" id="patterns-container">
          <div class="patterns-filters">
            <div class="filter-group">
              <label>Carrier</label>
              <select id="pattern-carrier-filter">
                <option value="">All Carriers</option>
              </select>
            </div>
            <div class="filter-group">
              <label>Customer</label>
              <select id="pattern-customer-filter">
                <option value="">All Customers</option>
              </select>
            </div>
            <div class="filter-group date-range">
              <label>From</label>
              <input type="date" id="pattern-date-from">
            </div>
            <div class="filter-group date-range">
              <label>To</label>
              <input type="date" id="pattern-date-to">
            </div>
            <button class="btn btn-secondary" id="btn-clear-pattern-filters">Clear</button>
          </div>
          <div class="patterns-stats" id="patterns-stats">
            <div class="pattern-summary">
              <span id="pattern-total">0</span> total placements analyzed
            </div>
            <div class="pattern-range" id="pattern-range"></div>
          </div>
          <div class="patterns-heatmap-grid" id="patterns-heatmap-grid">
            <div class="patterns-loading">Loading door patterns...</div>
          </div>
          <div class="patterns-legend">
            <span class="legend-item"><span class="legend-color none"></span> No data</span>
            <div class="legend-gradient-bar">
              <div class="gradient-track"></div>
              <div class="gradient-labels">
                <span>Low</span>
                <span>Medium</span>
                <span>High</span>
              </div>
            </div>
          </div>
          <div class="patterns-combos" id="patterns-combos">
            <h4>Top Carrier/Customer Combinations</h4>
            <div class="patterns-list" id="patterns-list"></div>
          </div>
        </div>
        <div class="analytics-summary" id="dwell-summary">
          <div class="summary-stat">
            <span class="stat-label">Avg Dwell Time</span>
            <span id="avg-dwell" class="stat-value">--</span>
          </div>
          <div class="summary-stat">
            <span class="stat-label">Trailers Tracked</span>
            <span id="tracked-count" class="stat-value">--</span>
          </div>
          <div class="summary-stat">
            <span class="stat-label">Data Points</span>
            <span id="data-points" class="stat-value">--</span>
          </div>
        </div>
        <div class="analytics-info" id="dwell-info">
          <p>üìà <strong>Tracking Method:</strong> Daily dwell calculated from movement history. Each trailer's actual time at dock is computed from arrival (MOVED_TO_DOOR) to departure (MOVED_TO_YARD/deleted).</p>
          <p>üìä <strong>Data Accuracy:</strong> Precise dwell times calculated retroactively from complete history - not sampled snapshots.</p>
          <p>üîÑ <strong>Dwell Reset:</strong> When you reset a trailer's dwell time, tracking restarts from that point for future calculations.</p>
        </div>
      </div>
      <div class="modal-actions">
        ${editMode ? `<button class="btn btn-success" id="btn-capture-now">üì∏ Force Calculation</button>
        <button class="btn btn-primary" id="btn-refresh-analytics">üîÑ Refresh</button>` : ''}
        <button class="btn btn-secondary" id="btn-export-patterns">üì• Export CSV</button>
        ${editMode ? `<button class="btn btn-danger" id="btn-clear-analytics">üóëÔ∏è Clear All History</button>` : ''}
        <button class="btn btn-secondary close-modal">Close</button>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  let currentPeriod = 'day';
  let analyticsData = null;
  
  async function loadAnalytics(period) {
    try {
      const response = await fetch(`${API_BASE}/api/analytics?period=${period}`);
      if (!response.ok) throw new Error('Failed to load analytics');
      analyticsData = await response.json();
      // Delay chart render until DOM is laid out
      requestAnimationFrame(() => {
        renderChart(analyticsData, period);
        updateSummary(analyticsData);
      });
    } catch (error) {
      console.error('Analytics error:', error);
      showToast('Failed to load analytics: ' + error.message, 'error');
    }
  }
  
  function updateSummary(data) {
    if (!data || !data.data) return;
    
    const totalDwell = data.data.reduce((sum, d) => sum + d.avgDwell, 0);
    const avg = data.data.length > 0 ? (totalDwell / data.data.length).toFixed(1) : '--';
    const totalTracked = data.data.reduce((sum, d) => sum + (d.count || 0), 0);
    
    document.getElementById('avg-dwell').textContent = avg === '--' ? '--' : `${avg}h`;
    document.getElementById('tracked-count').textContent = totalTracked || '--';
    document.getElementById('data-points').textContent = data.data.length || '--';
  }
  
  function renderChart(data, period) {
    const canvas = document.getElementById('analytics-chart');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    
    // Set canvas size with DPI scaling
    const rect = canvas.getBoundingClientRect();
    
    // If canvas has no size, set a default
    if (rect.width === 0 || rect.height === 0) {
      canvas.width = 800 * dpr;
      canvas.height = 400 * dpr;
    } else {
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
    }
    
    ctx.scale(dpr, dpr);
    
    const width = canvas.width / dpr;
    const height = canvas.height / dpr;
    const padding = { top: 40, right: 40, bottom: 60, left: 60 };
    const chartWidth = width - padding.left - padding.right;
    const chartHeight = height - padding.top - padding.bottom;
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (!data || !data.data || data.data.length === 0) {
      ctx.fillStyle = '#94a3b8';
      ctx.font = '16px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('No data available yet - check back after 15 min', width / 2, height / 2);
      return;
    }
    
    // Find max value for scaling
    const maxDwell = Math.max(...data.data.map(d => d.avgDwell || 0), 6);
    
    // Draw axes
    ctx.strokeStyle = 'rgba(148, 163, 184, 0.3)';
    ctx.lineWidth = 1;
    
    // Y-axis label
    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('Avg Dwell (hours)', padding.left - 10, padding.top - 10);
    
    // Draw grid lines and Y labels
    const ySteps = 5;
    for (let i = 0; i <= ySteps; i++) {
      const y = padding.top + chartHeight - (i / ySteps) * chartHeight;
      
      // Grid line
      ctx.beginPath();
      ctx.moveTo(padding.left, y);
      ctx.lineTo(width - padding.right, y);
      ctx.stroke();
      
      // Y label
      const value = (i / ySteps) * maxDwell;
      ctx.fillStyle = '#94a3b8';
      ctx.textAlign = 'right';
      ctx.fillText(value.toFixed(1) + 'h', padding.left - 10, y + 4);
    }
    
    // Draw bars
    const barWidth = chartWidth / data.data.length * 0.6;
    const barSpacing = chartWidth / data.data.length * 0.4;
    
    data.data.forEach((d, i) => {
      const x = padding.left + (i * (barWidth + barSpacing)) + barSpacing / 2;
      const barHeight = ((d.avgDwell || 0) / maxDwell) * chartHeight;
      const y = padding.top + chartHeight - barHeight;
      
      // Bar color based on value
      const hue = Math.max(0, 120 - ((d.avgDwell || 0) / 6) * 120); // Green (120) to Red (0)
      ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
      
      // Bar
      ctx.fillRect(x, y, barWidth, barHeight);
      
      // Bar top highlight
      ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
      ctx.fillRect(x, y, barWidth, 3);
      
      // Value label on bar
      if (barHeight > 20) {
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText((d.avgDwell || 0).toFixed(1) + 'h', x + barWidth / 2, y + 15);
      }
      
      // X label
      ctx.fillStyle = '#94a3b8';
      ctx.font = '11px sans-serif';
      ctx.textAlign = 'center';
      ctx.save();
      ctx.translate(x + barWidth / 2, padding.top + chartHeight + 15);
      ctx.rotate(-Math.PI / 6);
      ctx.fillText(d.label || d.date, 0, 0);
      ctx.restore();
    });
    
    // Title
    ctx.fillStyle = '#f1f5f9';
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'center';
    const periodLabel = period === 'day' ? 'Daily' : period === 'week' ? 'Weekly' : 'Monthly';
    ctx.fillText(`${periodLabel} Average Dwell Time`, width / 2, 20);
  }
  
  // Tab handlers
  let currentView = 'dwell';
  
  // Main view tabs (Dwell vs Violations)
  modal.querySelectorAll('.analytics-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      modal.querySelectorAll('.analytics-tab').forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      currentView = tab.dataset.view;
      
      // Hide all views first
      document.getElementById('chart-container')?.classList.add('hidden');
      document.getElementById('violations-container')?.classList.add('hidden');
      document.getElementById('patterns-container')?.classList.add('hidden');
      document.getElementById('dwell-summary')?.classList.add('hidden');
      document.getElementById('dwell-info')?.classList.add('hidden');
      document.getElementById('dwell-tabs')?.classList.add('hidden');
      
      // Show appropriate view
      if (currentView === 'dwell') {
        document.getElementById('chart-container')?.classList.remove('hidden');
        document.getElementById('dwell-summary')?.classList.remove('hidden');
        document.getElementById('dwell-info')?.classList.remove('hidden');
        document.getElementById('dwell-tabs')?.classList.remove('hidden');
        document.getElementById('btn-capture-now')?.classList.remove('hidden');
        document.getElementById('btn-export-patterns')?.classList.add('hidden');
        loadAnalytics(currentPeriod);
      } else if (currentView === 'violations') {
        document.getElementById('violations-container')?.classList.remove('hidden');
        document.getElementById('btn-capture-now')?.classList.remove('hidden');
        document.getElementById('btn-export-patterns')?.classList.add('hidden');
        loadViolations();
      } else if (currentView === 'patterns') {
        document.getElementById('patterns-container')?.classList.remove('hidden');
        document.getElementById('btn-capture-now')?.classList.add('hidden');
        document.getElementById('btn-export-patterns')?.classList.remove('hidden');
        loadPatterns();
      }
    });
  });
  
  // Dwell period subtabs
  modal.querySelectorAll('.analytics-subtab').forEach(tab => {
    tab.addEventListener('click', () => {
      modal.querySelectorAll('.analytics-subtab').forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      currentPeriod = tab.dataset.period;
      loadAnalytics(currentPeriod);
    });
  });
  
  // Load violations data
  async function loadViolations() {
    try {
      // Load current violations
      const currentRes = await fetch(`${API_BASE}/api/analytics/current-violations`);
      const currentData = currentRes.ok ? await currentRes.json() : { count: 0, trailers: [] };
      
      document.getElementById('current-violation-count').textContent = currentData.count;
      
      const list = document.getElementById('violations-list');
      if (currentData.trailers.length === 0) {
        list.innerHTML = '<div class="violations-empty">‚úÖ No trailers currently exceeding 2 hours</div>';
      } else {
        list.innerHTML = currentData.trailers.map(t => `
          <div class="violation-item" data-trailer-id="${t.id}">
            <div class="violation-main">
              <span class="violation-carrier">${t.carrier}</span>
              ${t.number ? `<span class="violation-number">${t.number}</span>` : ''}
              <span class="viocation-location">Door ${t.doorNumber || '?'}</span>
            </div>
            <div class="violation-meta">
              <span class="violation-dwell ${t.dwellHours >= 3 ? 'critical' : 'warning'}">${t.dwellHours.toFixed(1)}h</span>
              ${t.customer ? `<span class="violation-customer">${t.customer}</span>` : ''}
            </div>
          </div>
        `).join('');
        
        // Add click handlers to open edit modal
        list.querySelectorAll('.violation-item').forEach(item => {
          item.addEventListener('dblclick', () => {
            const trailerId = item.dataset.trailerId;
            const trailer = state.trailers.find(t => t.id === trailerId);
            if (trailer) {
              openTrailerEditModal(trailerId);
            }
          });
        });
      }
      
      // Load historical violation counts
      const histRes = await fetch(`${API_BASE}/api/analytics/violations?period=day`);
      const histData = histRes.ok ? await histRes.json() : { data: [] };
      
      renderViolationsChart(histData.data);
      
    } catch (error) {
      console.error('Violations load error:', error);
      document.getElementById('violations-list').innerHTML = '<div class="violations-empty">Failed to load</div>';
    }
  }
  
  function renderViolationsChart(data) {
    const canvas = document.getElementById('violations-chart');
    if (!canvas || !data || data.length === 0) return;
    
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    
    canvas.width = (rect.width || 800) * dpr;
    canvas.height = (rect.height || 300) * dpr;
    ctx.scale(dpr, dpr);
    
    const width = rect.width || 800;
    const height = rect.height || 300;
    const padding = { top: 30, right: 20, bottom: 50, left: 50 };
    const chartWidth = width - padding.left - padding.right;
    const chartHeight = height - padding.top - padding.bottom;
    
    // Clear
    ctx.clearRect(0, 0, width, height);
    
    // Find max
    const maxCount = Math.max(...data.map(d => d.count || 0), 5);
    
    // Draw grid
    ctx.strokeStyle = 'rgba(148, 163, 184, 0.2)';
    ctx.lineWidth = 1;
    
    const ySteps = 5;
    for (let i = 0; i <= ySteps; i++) {
      const y = padding.top + chartHeight - (i / ySteps) * chartHeight;
      ctx.beginPath();
      ctx.moveTo(padding.left, y);
      ctx.lineTo(width - padding.right, y);
      ctx.stroke();
      
      ctx.fillStyle = '#94a3b8';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'right';
      ctx.fillText(Math.round((i / ySteps) * maxCount).toString(), padding.left - 10, y + 4);
    }
    
    // Draw bars
    const barWidth = chartWidth / data.length * 0.7;
    const spacing = chartWidth / data.length * 0.3;
    
    data.forEach((d, i) => {
      const x = padding.left + i * (barWidth + spacing) + spacing / 2;
      const barHeight = ((d.count || 0) / maxCount) * chartHeight;
      const y = padding.top + chartHeight - barHeight;
      
      // Red bars for violations
      ctx.fillStyle = d.count > 0 ? 'rgba(239, 68, 68, 0.8)' : 'rgba(148, 163, 184, 0.3)';
      ctx.fillRect(x, y, barWidth, barHeight);
      
      // Label
      ctx.fillStyle = '#94a3b8';
      ctx.font = '11px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(d.label || '', x + barWidth / 2, height - 20);
      
      // Count on bar
      if (d.count > 0) {
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px sans-serif';
        ctx.fillText(d.count.toString(), x + barWidth / 2, y - 5);
      }
    });
  }
  
  // Refresh handler
  document.getElementById('btn-refresh-analytics')?.addEventListener('click', () => {
    if (currentView === 'dwell') {
      loadAnalytics(currentPeriod);
    } else if (currentView === 'violations') {
      loadViolations();
    } else if (currentView === 'patterns') {
      loadPatterns();
    }
  });
  
  // Position Patterns functions
  let currentPatternFilters = { carrier: '', customer: '', dateFrom: '', dateTo: '' };
  
  // Set default dates (last 30 days)
  const today = new Date().toISOString().split('T')[0];
  const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
  
  async function loadPatterns() {
    try {
      const params = new URLSearchParams();
      if (currentPatternFilters.carrier) params.append('carrier', currentPatternFilters.carrier);
      if (currentPatternFilters.customer) params.append('customer', currentPatternFilters.customer);
      if (currentPatternFilters.dateFrom) params.append('dateFrom', currentPatternFilters.dateFrom);
      if (currentPatternFilters.dateTo) params.append('dateTo', currentPatternFilters.dateTo);
      
      const response = await fetch(`${API_BASE}/api/analytics/position-patterns?${params}`);
      if (!response.ok) throw new Error('Failed to load patterns');
      const data = await response.json();
      
      // Update filter options
      const carrierSelect = document.getElementById('pattern-carrier-filter');
      const customerSelect = document.getElementById('pattern-customer-filter');
      
      if (carrierSelect && data.availableCarriers) {
        const currentVal = carrierSelect.value;
        carrierSelect.innerHTML = '<option value="">All Carriers</option>' +
          data.availableCarriers.map(c => `<option value="${c}" ${c === currentVal ? 'selected' : ''}>${c}</option>`).join('');
      }
      
      if (customerSelect && data.availableCustomers) {
        const currentVal = customerSelect.value;
        customerSelect.innerHTML = '<option value="">All Customers</option>' +
          data.availableCustomers.map(c => `<option value="${c}" ${c === currentVal ? 'selected' : ''}>${c}</option>`).join('');
      }
      
      // Update stats
      document.getElementById('pattern-total').textContent = data.totalPlacements || 0;
      
      const rangeEl = document.getElementById('pattern-range');
      if (data.doorRange) {
        rangeEl.innerHTML = `
          <span class="range-stat">Doors ${data.doorRange.min} - ${data.doorRange.max}</span>
          <span class="range-stat">Avg: Door ${data.doorRange.avg}</span>
        `;
      } else {
        rangeEl.innerHTML = '<span class="range-stat">No data</span>';
      }
      
      // Render heatmap grid
      renderPatternsHeatmap(data.doorStats || []);
      
      // Render combos list
      const combosList = document.getElementById('patterns-list');
      if (!data.topCombos || data.topCombos.length === 0) {
        combosList.innerHTML = '<div class="patterns-empty">No carrier/customer patterns found</div>';
      } else {
        combosList.innerHTML = data.topCombos.map(combo => `
          <div class="pattern-combo-item" data-carrier="${combo.carrier}" data-customer="${combo.customer}">
            <div class="combo-header">
              <span class="combo-carrier">${combo.carrier}</span>
              <span class="combo-arrow">‚Üí</span>
              <span class="combo-customer">${combo.customer}</span>
              <span class="combo-total">${combo.total} placements</span>
            </div>
            <div class="combo-doors">
              ${combo.preferredDoors.map(d => `
                <span class="combo-door" title="${d.percentage}% of time">
                  Door ${d.door} <small>(${d.percentage}%)</small>
                </span>
              `).join('')}
            </div>
          </div>
        `).join('');
        
        // Add click to filter
        combosList.querySelectorAll('.pattern-combo-item').forEach(item => {
          item.addEventListener('click', () => {
            document.getElementById('pattern-carrier-filter').value = item.dataset.carrier;
            document.getElementById('pattern-customer-filter').value = item.dataset.customer;
            currentPatternFilters = { 
              carrier: item.dataset.carrier, 
              customer: item.dataset.customer 
            };
            loadPatterns();
          });
        });
      }
      
    } catch (error) {
      console.error('Patterns load error:', error);
      document.getElementById('patterns-list').innerHTML = '<div class="patterns-empty">Failed to load patterns</div>';
    }
  }
  
  // Store current pattern data for click handlers
  let currentPatternData = [];
  
  function showDoorPatternModal(doorNumber, doorData) {
    // Debug: alert to confirm function is called
    console.log('showDoorPatternModal called for door', doorNumber, doorData);
    
    const carriers = doorData?.carriers || [];
    const customers = doorData?.customers || [];
    
    const carriersHtml = carriers.length > 0 
      ? carriers.map(([name, count]) => `<div class="door-stat-item"><span class="stat-name">${escapeHtml(name)}</span><span class="stat-count">${count}</span></div>`).join('')
      : '<div class="door-stat-empty">No carrier data</div>';
    
    const customersHtml = customers.length > 0
      ? customers.map(([name, count]) => `<div class="door-stat-item"><span class="stat-name">${escapeHtml(name)}</span><span class="stat-count">${count}</span></div>`).join('')
      : '<div class="door-stat-empty">No customer data</div>';
    
    const modal = document.createElement('div');
    modal.id = 'door-pattern-modal';
    modal.className = 'modal';
    modal.style.display = 'flex';
    modal.innerHTML = `
      <div class="modal-content modal-small" style="max-width: 400px;">
        <div class="modal-header">
          <h2>üö™ Door ${doorNumber} Details</h2>
          <button class="close-modal" style="background:none;border:none;color:var(--text-muted);font-size:1.5rem;cursor:pointer;">&times;</button>
        </div>
        <div class="modal-body" style="padding: 1rem;">
          <div class="door-stats-grid" style="display:grid;grid-template-columns:1fr 1fr;gap:1rem;">
            <div class="door-stat-section">
              <h4 style="margin:0 0 0.5rem 0;font-size:0.875rem;color:var(--text-secondary);">Carriers (${carriers.length})</h4>
              <div class="door-stat-list" style="max-height:200px;overflow-y:auto;">${carriersHtml}</div>
            </div>
            <div class="door-stat-section">
              <h4 style="margin:0 0 0.5rem 0;font-size:0.875rem;color:var(--text-secondary);">Customers (${customers.length})</h4>
              <div class="door-stat-list" style="max-height:200px;overflow-y:auto;">${customersHtml}</div>
            </div>
          </div>
          <div class="door-stat-total" style="margin-top:1rem;padding-top:0.75rem;border-top:1px solid var(--border-color);text-align:center;">Total placements: <strong>${doorData?.frequency || 0}</strong></div>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Close handlers
    const closeModal = () => modal.remove();
    modal.querySelector('.close-modal')?.addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
      if (e.target === modal) closeModal();
    });
    
    // Focus trap
    modal.querySelector('.close-modal')?.focus();
  }
  
  function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
  
  function renderPatternsHeatmap(doorStats) {
    const grid = document.getElementById('patterns-heatmap-grid');
    if (!grid) return;
    
    // Store data for click handlers
    currentPatternData = doorStats;
    const doorDataMap = {};
    doorStats.forEach(d => {
      doorDataMap[d.doorNumber] = d;
    });
    
    // Find max for intensity scaling
    const maxFreq = Math.max(...doorStats.map(d => d.frequency), 0);
    
    // Generate all door numbers (1-57 based on warehouse setup)
    const doors = [];
    for (let i = 1; i <= 57; i++) {
      const doorData = doorDataMap[i];
      const freq = doorData?.frequency || 0;
      
      // Continuous gradient based on intensity
      let intensity = 0;
      let bgColor = 'transparent';
      let borderColor = 'var(--border-color)';
      let glowOpacity = 0;
      
      if (freq > 0 && maxFreq > 0) {
        intensity = freq / maxFreq;
        
        // Hue gradient: 220¬∞ (blue) ‚Üí 270¬∞ (purple) ‚Üí 330¬∞ (pink/red)
        // More granular - 10 distinct levels visually
        let hue;
        if (intensity <= 0.1) hue = 215;      // Light blue
        else if (intensity <= 0.2) hue = 225; // Blue
        else if (intensity <= 0.3) hue = 235; // Blue-purple
        else if (intensity <= 0.4) hue = 245; // Purple-blue
        else if (intensity <= 0.5) hue = 260; // Purple
        else if (intensity <= 0.6) hue = 275; // Purple-magenta
        else if (intensity <= 0.7) hue = 290; // Magenta
        else if (intensity <= 0.8) hue = 310; // Pink-magenta
        else if (intensity <= 0.9) hue = 330; // Pink
        else hue = 350;                         // Red-pink (hot!)
        
        // Saturation increases with intensity (more vibrant = more activity)
        const saturation = 50 + intensity * 50; // 50-100%
        
        // Lightness decreases slightly as intensity increases (darker = more activity)
        const lightness = 55 - intensity * 20; // 55-35%
        
        bgColor = `hsla(${hue}, ${saturation}%, ${lightness}%, ${0.3 + intensity * 0.7})`;
        borderColor = `hsla(${hue}, ${saturation}%, ${lightness - 10}%, 0.9)`;
        glowOpacity = intensity * 0.4;
      }
      
      doors.push({
        number: i,
        frequency: freq,
        intensity,
        bgColor,
        borderColor,
        glowOpacity,
        hasData: !!doorData
      });
    }
    
    grid.innerHTML = doors.map(d => `
      <div class="pattern-heat-cell ${d.frequency > 0 ? 'has-data' : ''}" 
           style="background: ${d.bgColor}; border-color: ${d.borderColor}; --glow-opacity: ${d.glowOpacity}"
           data-door="${d.number}"
           data-has-data="${d.hasData}"
           data-intensity="${Math.round(d.intensity * 100)}"
           title="Door ${d.number}: ${d.frequency} placements (${Math.round(d.intensity * 100)}%)">
        <span class="pattern-door-num">${d.number}</span>
        ${d.frequency > 0 ? `<span class="pattern-door-freq">${d.frequency}</span>` : ''}
      </div>
    `).join('');
    
    // Add click handler using event delegation (more reliable)
    grid.onclick = (e) => {
      const cell = e.target.closest('.pattern-heat-cell');
      if (!cell) return;
      
      const doorNum = parseInt(cell.dataset.door);
      const doorData = doorDataMap[doorNum];
      console.log('Clicked door', doorNum, 'data:', doorData);
      
      // Show modal even if no data
      showDoorPatternModal(doorNum, doorData || { frequency: 0, carriers: [], customers: [] });
    };
  }
  
  // Pattern filter handlers
  document.getElementById('pattern-carrier-filter')?.addEventListener('change', (e) => {
    currentPatternFilters.carrier = e.target.value;
    loadPatterns();
  });
  
  document.getElementById('pattern-customer-filter')?.addEventListener('change', (e) => {
    currentPatternFilters.customer = e.target.value;
    loadPatterns();
  });
  
  document.getElementById('pattern-date-from')?.addEventListener('change', (e) => {
    currentPatternFilters.dateFrom = e.target.value;
    loadPatterns();
  });
  
  document.getElementById('pattern-date-to')?.addEventListener('change', (e) => {
    currentPatternFilters.dateTo = e.target.value;
    loadPatterns();
  });
  
  document.getElementById('btn-clear-pattern-filters')?.addEventListener('click', () => {
    document.getElementById('pattern-carrier-filter').value = '';
    document.getElementById('pattern-customer-filter').value = '';
    document.getElementById('pattern-date-from').value = '';
    document.getElementById('pattern-date-to').value = '';
    currentPatternFilters = { carrier: '', customer: '', dateFrom: '', dateTo: '' };
    loadPatterns();
  });
  
  // Export patterns to CSV
  document.getElementById('btn-export-patterns')?.addEventListener('click', async () => {
    try {
      const params = new URLSearchParams();
      if (currentPatternFilters.carrier) params.append('carrier', currentPatternFilters.carrier);
      if (currentPatternFilters.customer) params.append('customer', currentPatternFilters.customer);
      if (currentPatternFilters.dateFrom) params.append('dateFrom', currentPatternFilters.dateFrom);
      if (currentPatternFilters.dateTo) params.append('dateTo', currentPatternFilters.dateTo);
      
      const response = await fetch(`${API_BASE}/api/analytics/position-patterns?${params}`);
      const data = await response.json();
      
      // Build CSV
      let csv = 'Door Number,Frequency,Top Carriers,Top Customers\n';
      data.doorStats.forEach(d => {
        const carriers = d.topCarriers.map(([c, count]) => `${c} (${count})`).join('; ');
        const customers = d.topCustomers.map(([c, count]) => `${c} (${count})`).join('; ');
        csv += `${d.doorNumber},${d.frequency},"${carriers}","${customers}"\n`;
      });
      
      // Download
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `door-patterns-${new Date().toISOString().split('T')[0]}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showToast('CSV exported!', 'success');
    } catch (error) {
      showToast('Export failed: ' + error.message, 'error');
    }
  });
  
  // Force Calculation handler - recalculate today's dwell from history
  document.getElementById('btn-capture-now')?.addEventListener('click', async () => {
    try {
      const response = await fetch(`${API_BASE}/api/analytics/snapshot`, { method: 'POST' });
      if (response.ok) {
        showToast('Daily dwell recalculated!', 'success');
        // Reload current view after brief delay
        setTimeout(() => {
          if (currentView === 'dwell') {
            loadAnalytics(currentPeriod);
          }
        }, 500);
      } else {
        showToast('Failed to recalculate dwell', 'error');
      }
    } catch (error) {
      showToast('Error: ' + error.message, 'error');
    }
  });
  
  // Clear analytics handler (edit mode only)
  document.getElementById('btn-clear-analytics')?.addEventListener('click', async () => {
    if (!confirm('‚ö†Ô∏è WARNING: This will permanently delete ALL analytics history!\n\nThis action cannot be undone. Continue?')) return;
    if (!confirm('Are you absolutely sure? All daily dwell aggregates will be lost.')) return;
    
    try {
      const response = await fetch(`${API_BASE}/api/analytics`, { method: 'DELETE' });
      if (response.ok) {
        showToast('Analytics history cleared', 'success');
        setTimeout(() => loadAnalytics(currentPeriod), 500);
      } else {
        showToast('Failed to clear analytics', 'error');
      }
    } catch (error) {
      showToast('Error: ' + error.message, 'error');
    }
  });
  
  // Close handlers
  modal.querySelectorAll('.close-modal').forEach(btn => {
    btn.addEventListener('click', () => modal.remove());
  });
  
  // Initial load
  loadAnalytics(currentPeriod);
}

// ============================================================================
// Helper Functions
// ============================================================================

function generateTrailerNumber() {
  // Generate a random trailer number: TR-[timestamp]-[random]
  const timestamp = Date.now().toString(36).toUpperCase().slice(-4);
  const random = Math.random().toString(36).toUpperCase().slice(-3);
  return `TR-${timestamp}-${random}`;
}

function renderQuickCarrierButtons() {
  const container = document.getElementById('quick-carrier-buttons');
  const targetDoor = document.getElementById('form-create-trailer')?.dataset.targetDoor;
  
  if (!container) return;
  
  // Update target door display
  const targetDoorEl = document.getElementById('quick-target-door');
  if (targetDoorEl) {
    targetDoorEl.textContent = targetDoor || 'Yard';
  }
  
  // Separate favorites and non-favorites
  const favorites = state.carriers.filter(c => c.favorite).sort((a, b) => a.name.localeCompare(b.name));
  const nonFavorites = state.carriers.filter(c => !c.favorite).sort((a, b) => (b.usageCount || 0) - (a.usageCount || 0));
  
  // Take top 6 non-favorites by usage
  const topNonFavorites = nonFavorites.slice(0, 6);

  if (favorites.length === 0 && topNonFavorites.length === 0) {
    container.innerHTML = '<span class="no-carriers-msg">No carriers yet. Add one below.</span>';
    return;
  }

  let html = '';
  
  // Favorites section (fixed positions)
  if (favorites.length > 0) {
    html += `<div class="quick-carrier-grid favorites-grid">`;
    html += favorites.map(carrier => `
      <button type="button" class="quick-carrier-btn favorite-btn" data-carrier="${carrier.name}">
        ‚≠ê ${carrier.name}
      </button>
    `).join('');
    html += `</div>`;
  }
  
  // Separator if both sections exist
  if (favorites.length > 0 && topNonFavorites.length > 0) {
    html += `<div class="quick-carrier-separator"></div>`;
  }
  
  // Non-favorites section (sorted by usage, floats to top)
  if (topNonFavorites.length > 0) {
    html += `<div class="quick-carrier-grid">`;
    html += topNonFavorites.map(carrier => `
      <button type="button" class="quick-carrier-btn" data-carrier="${carrier.name}">
        ${carrier.name}
        ${carrier.usageCount ? `<span class="usage-count">(${carrier.usageCount})</span>` : ''}
      </button>
    `).join('');
    html += `</div>`;
  }
  
  container.innerHTML = html;

  // Add click handlers
  container.querySelectorAll('.quick-carrier-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
      const carrierName = btn.dataset.carrier;
      const targetDoor = document.getElementById('form-create-trailer')?.dataset.targetDoor;
      
      try {
        // Find carrier to get ID for usage tracking
        const carrier = state.carriers.find(c => c.name === carrierName);
        
        // Quick add - no trailer number required
        const result = await createTrailer({
          carrier: carrierName,
          status: 'empty' // Default to empty for quick add
        });
        
        // Increment usage count
        if (carrier) {
          apiCall(`/carriers/${carrier.id}/use`, 'POST').catch(() => {});
          carrier.usageCount = (carrier.usageCount || 0) + 1;
        }
        
        const trailerId = result.trailer?.id;
        
        // If door was clicked, move trailer there
        if (targetDoor && trailerId) {
          await moveToDoor(trailerId, parseInt(targetDoor));
          showToast(`‚úÖ ${carrierName} trailer placed in Door ${targetDoor}!`, 'success');
        } else {
          showToast(`‚úÖ ${carrierName} trailer added to yard!`, 'success');
        }
        
        closeModal('modal-create');
        delete document.getElementById('form-create-trailer').dataset.targetDoor;
        await fetchState();
      } catch (error) {
        showToast(error.message, 'error');
      }
    });
  });
}

// ============================================================================
// State Management
// ============================================================================

async function fetchState() {
  if (isPaused) return;
  
  try {
    const newState = await getState();
    state.doors = newState.doors || [];
    state.trailers = newState.trailers || [];
    state.yardTrailers = newState.yardTrailers || [];
    state.yardSlots = newState.yardSlots || [];
    state.carriers = newState.carriers || [];
    
    // Only render if state changed (reduce DOM updates)
    renderAll();
    
    // Reset error tracking on success
    if (consecutiveErrors > 0) {
      consecutiveErrors = 0;
      fetchErrorShown = false;
      // Resume normal polling speed
      clearInterval(pollingInterval);
      pollingInterval = setInterval(fetchState, NORMAL_POLL_INTERVAL);
    }
  } catch (error) {
    consecutiveErrors++;
    console.error(`Fetch error (${consecutiveErrors}/${MAX_CONSECUTIVE_ERRORS}):`, error);
    
    if (!fetchErrorShown) {
      showToast('Connection error - retrying...', 'warning');
      fetchErrorShown = true;
    }
    
    // Slow down polling after errors
    if (consecutiveErrors >= 3) {
      clearInterval(pollingInterval);
      pollingInterval = setInterval(fetchState, ERROR_POLL_INTERVAL);
    }
    
    // Pause entirely if too many errors (server likely restarting)
    if (consecutiveErrors >= MAX_CONSECUTIVE_ERRORS) {
      isPaused = true;
      console.log('Too many errors, pausing polling for 60s...');
      setTimeout(() => {
        isPaused = false;
        consecutiveErrors = 0;
        pollingInterval = setInterval(fetchState, NORMAL_POLL_INTERVAL);
        fetchState(); // Try once more
      }, 60000);
    }
  }
}

function startPolling() {
  renderAll(); // Render empty grid immediately
  fetchState(); // Then fetch real data
  pollingInterval = setInterval(fetchState, NORMAL_POLL_INTERVAL);
}

function renderAll() {
  renderDoors();
  renderYardSlots();
  renderUnassignedYard();
  updateStats();
  renderCarrierSelect();
  renderCarrierSummary();
  updateUndoButton();
}

// ============================================================================
// Render Functions  
// ============================================================================

function renderDoors() {
  const grid = document.getElementById('dock-grid');
  if (!grid) return;

  let html = '';
  // Sort doors by order field (if set), then by number. Door numbers stay fixed.
  const sortedDoors = [...state.doors].sort((a, b) => {
    // Use explicit order if both have it
    if (a.order !== undefined && b.order !== undefined) {
      return a.order - b.order;
    }
    // Fall back to number sort if no explicit order
    return a.number - b.number;
  });

  for (const door of sortedDoors) {
    const trailer = door?.trailerId ? state.trailers.find(t => t.id === door.trailerId) : null;
    const doorNum = door.number;
    const hasTextLabel = door.labelText && door.labelText.trim();
    const displayLabel = hasTextLabel ? door.labelText : `Door ${doorNum}`;
    const textLabelClass = hasTextLabel ? 'has-text-label' : '';
    
    // Check search match
    let searchClass = '';
    if (searchQuery && trailer) {
      if (isTrailerInSearchResults(trailer.id)) {
        searchClass = 'search-match';
      } else {
        searchClass = 'search-mismatch';
      }
    } else if (searchQuery && !trailer) {
      searchClass = 'search-mismatch';
    }
    
    // Determine highlight state from carrier filter
    let highlightClass = '';
    if (activeCarrierFilter && trailer) {
      if (trailer.carrier === activeCarrierFilter) {
        highlightClass = 'highlighted';
      } else {
        highlightClass = 'dimmed';
      }
    } else if (activeCarrierFilter && !trailer) {
      highlightClass = 'dimmed';
    }

    // Out of service door
    if (door.inService === false) {
      html += `
        <div class="dock-door out-of-service ${highlightClass} ${searchClass} ${textLabelClass} ${editMode ? 'door-draggable' : ''}" data-door="${doorNum}" data-door-id="${door.id}" ${editMode ? 'draggable="true"' : ''}>
          <div class="door-header">
            <span class="door-number">${displayLabel}</span>
            <span class="badge">üîß Out of Service</span>
          </div>
          <div class="door-content">
            ${hasTextLabel ? `<span class="door-text-label ${door.labelText.length > 6 ? 'long-label' : ''}">${door.labelText}</span>` : '<span class="out-of-service-text">Unavailable</span>'}
          </div>
          ${editMode ? `<button class="door-edit-btn" data-door-id="${door.id}" style="opacity: 1">‚öôÔ∏è</button>` : ''}
        </div>
      `;
      continue;
    }

    // Blank/dummy door (spacer)
    if (door.type === 'blank') {
      html += `
        <div class="dock-door blank ${highlightClass} ${searchClass} ${textLabelClass} ${editMode ? 'door-draggable' : ''}" data-door="${doorNum}" data-door-id="${door.id}" ${editMode ? 'draggable="true"' : ''}>
          <div class="door-header">
            <span class="door-number">${displayLabel}</span>
            <span class="door-status">Blank</span>
          </div>
          <div class="door-content">
            ${hasTextLabel ? `<span class="door-text-label ${door.labelText.length > 6 ? 'long-label' : ''}">${door.labelText}</span>` : '<span class="blank-text">‚Äî</span>'}
          </div>
          ${editMode ? `<button class="door-edit-btn" data-door-id="${door.id}" style="opacity: 1">‚öôÔ∏è</button>` : ''}
        </div>
      `;
      continue;
    }

    // Normal door with trailer
    if (trailer) {
      const statusBadge = trailer.status === 'loaded' ? 
        `<span class="badge loaded status-toggle" data-trailer-id="${trailer.id}">üì¶ Loaded</span>` : 
        `<span class="badge empty status-toggle" data-trailer-id="${trailer.id}">üì≠ Empty</span>`;
      const statusClass = trailer.status === 'loaded' ? 'status-loaded' : 'status-empty';
      
      // Dwell time
      const dwellClass = getDwellTimeClass(trailer.createdAt);
      const dwellTime = formatDwellTime(trailer.createdAt);
      const dwellBadge = dwellTime ? `<span class="dwell-badge ${dwellClass}">‚è±Ô∏è ${dwellTime}</span>` : '';
      
      // Selection state
      const selectedClass = selectedTrailers.has(trailer.id) ? 'selected' : '';

      html += `
        <div class="dock-door occupied ${highlightClass} ${statusClass} ${searchClass} ${dwellClass} ${textLabelClass} ${editMode ? 'door-draggable' : ''}" data-door="${doorNum}" data-door-id="${door.id}" ${editMode ? 'draggable="true"' : ''}>
          <div class="door-header">
            <span class="door-number">${displayLabel}</span>
            ${statusBadge}
          </div>
          <div class="door-content">
            ${hasTextLabel ? `<span class="door-text-label ${door.labelText.length > 6 ? 'long-label' : ''}">${door.labelText}</span>` : ''}
            <div class="trailer-card docked ${trailer.status} ${selectedClass} ${dwellClass}" draggable="true" data-trailer-id="${trailer.id}" data-location="door-${doorNum}">
              <div class="trailer-header-row">
                ${trailer.number ? `<span class="trailer-number">${trailer.number}</span>` : ''}
                ${dwellBadge}
                <button class="delete-trailer-btn" data-trailer-id="${trailer.id}" title="Delete trailer">üóëÔ∏è</button>
              </div>
              ${trailer.customer ? `<div class="trailer-customer">${trailer.customer}</div>` : ''}
              <div class="trailer-carrier">${trailer.carrier}</div>
              ${trailer.loadNumber ? `<div class="trailer-load-number-row">${trailer.loadNumber}</div>` : ''}
            </div>
          </div>
          ${editMode ? `<button class="door-edit-btn" data-door-id="${door.id}" style="opacity: 1">‚öôÔ∏è</button>` : ''}
        </div>
      `;
    } else {
      // Empty normal door
      const emptyContent = hasTextLabel 
        ? `<span class="door-text-label ${door.labelText.length > 6 ? 'long-label' : ''}">${door.labelText}</span>`
        : (editMode ? `<span class="placeholder-text">Drag to reorder</span>` : `<button class="quick-add-btn" data-door="${door.number}">+ Add</button>`);
      
      html += `
        <div class="dock-door empty ${highlightClass} ${searchClass} ${textLabelClass} ${editMode ? 'door-draggable' : ''}" data-door="${doorNum}" data-door-id="${door.id}" ${editMode ? 'draggable="true"' : ''}>
          <div class="door-header">
            <span class="door-number">${displayLabel}</span>
            <span class="door-status">Empty</span>
          </div>
          <div class="door-content">
            ${emptyContent}
          </div>
          ${editMode ? `<button class="door-edit-btn" data-door-id="${door.id}">‚öôÔ∏è</button>` : ''}
        </div>
      `;
    }
  }
  
  // Add "Add Door" button in edit mode
  if (editMode) {
    html += `
      <div class="dock-door add-door-card" id="btn-add-door">
        <div class="door-content">
          <span class="add-door-text">+ Add Door</span>
        </div>
      </div>
    `;
  }
  
  grid.innerHTML = html;
  
  // Add drag listeners to doors (edit mode only)
  if (editMode) {
    setupDoorDragAndDrop(grid);
  }
  
  // Add drag listeners to trailers
  grid.querySelectorAll('.trailer-card[draggable]').forEach(el => {
    el.addEventListener('dragstart', handleDragStart);
    el.addEventListener('dragend', handleDragEnd);
    el.addEventListener('click', (e) => {
      // Shift+Click to select/deselect
      if (isShiftPressed && !e.target.closest('.delete-trailer-btn')) {
        e.preventDefault();
        e.stopPropagation();
        toggleTrailerSelection(el.dataset.trailerId);
      }
    });
  });

  // Quick add buttons
  grid.querySelectorAll('.quick-add-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const doorNum = btn.dataset.door;
      
      document.getElementById('quick-add-panel')?.classList.remove('hidden');
      document.getElementById('form-create-trailer')?.classList.add('hidden');
      
      const form = document.getElementById('form-create-trailer');
      form.dataset.targetDoor = doorNum;
      
      renderQuickCarrierButtons();
      openModal('modal-create');
      
      setTimeout(() => {
        document.getElementById('quick-carrier-input')?.focus();
      }, 100);
    });
  });

  // Status badge double-click to toggle loaded/empty
  grid.querySelectorAll('.status-toggle').forEach(badge => {
    badge.style.cursor = 'pointer';
    badge.addEventListener('dblclick', async (e) => {
      e.stopPropagation();
      const trailerId = badge.dataset.trailerId;
      const trailer = state.trailers.find(t => t.id === trailerId);
      if (!trailer) return;
      
      const newStatus = trailer.status === 'loaded' ? 'empty' : 'loaded';
      try {
        await updateTrailer(trailerId, { status: newStatus });
        showToast(`Status changed to ${newStatus === 'loaded' ? 'üì¶ Loaded' : 'üì≠ Empty'}`, 'success');
        fetchState();
      } catch (error) {
        showToast(error.message, 'error');
      }
    });
  });

  // Trailer double-click to edit (but not on delete button)
  grid.querySelectorAll('.trailer-card').forEach(card => {
    card.style.cursor = 'pointer';
    card.addEventListener('dblclick', (e) => {
      if (!e.target.closest('.delete-trailer-btn') && !e.target.closest('.trailer-checkbox')) {
        openTrailerEditModal(card.dataset.trailerId);
      }
    });
  });
  
  grid.querySelectorAll('.delete-trailer-btn').forEach(btn => {
    btn.addEventListener('click', async (e) => {
      e.stopPropagation();
      const trailerId = btn.dataset.trailerId;
      const trailer = state.trailers.find(t => t.id === trailerId);
      if (!trailer) return;
      
      if (!confirm(`Delete trailer ${trailer.number} (${trailer.carrier})?\n\nThis will permanently remove it.`)) {
        return;
      }
      
      if (selectedTrailers.has(trailerId)) {
        selectedTrailers.delete(trailerId);
      }
      
      try {
        await deleteTrailer(trailerId);
        showToast('Trailer deleted', 'success');
        fetchState();
      } catch (error) {
        showToast(error.message, 'error');
      }
    });
  });

  // Door edit buttons (edit mode only)
  if (editMode) {
    grid.querySelectorAll('.door-edit-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const doorId = btn.dataset.doorId;
        openDoorEditor(doorId);
      });
    });

    // Add door button
    const addDoorBtn = document.getElementById('btn-add-door');
    if (addDoorBtn) {
      addDoorBtn.addEventListener('click', () => openAddDoorModal());
    }
  }
  
  // Update selection visual state
  updateSelectionUI();
}

function renderYardSlots() {
  const list = document.getElementById('yard-slots-list');
  const count = document.getElementById('yard-count');
  if (!list) return;

  // Get normal doors (not blanks) sorted by door number
  const normalDoors = state.doors
    .filter(d => d.type !== 'blank')
    .sort((a, b) => a.number - b.number);

  // Count trailers in yard slots
  const trailersInSlots = state.yardSlots.filter(s => s.trailerId).length;
  if (count) count.textContent = `${trailersInSlots}`;

  // Generate slots using actual door numbers
  list.innerHTML = normalDoors.map(door => {
    const doorNumber = door.number;
    const slot = state.yardSlots.find(s => s.number === doorNumber);
    const trailer = slot?.trailerId ? 
      state.trailers.find(t => t.id === slot.trailerId) || 
      state.yardTrailers.find(t => t.id === slot.trailerId) : null;
    
    // Search match
    let searchClass = '';
    if (searchQuery && trailer) {
      if (isTrailerInSearchResults(trailer.id)) {
        searchClass = 'search-match';
      } else {
        searchClass = 'search-mismatch';
      }
    } else if (searchQuery && !trailer) {
      searchClass = 'search-mismatch';
    }
    
    // Determine highlight state for carrier filter
    let highlightClass = '';
    if (activeCarrierFilter && trailer) {
      if (trailer.carrier === activeCarrierFilter) {
        highlightClass = 'highlighted';
      } else {
        highlightClass = 'dimmed';
      }
    } else if (activeCarrierFilter && !trailer) {
      highlightClass = 'dimmed';
    }
    
    // Selection state
    const selectedClass = trailer && selectedTrailers.has(trailer.id) ? 'selected' : '';
    
    if (trailer) {
      const statusText = trailer.status === 'loaded' ? 'LOADED' : 'EMPTY';
      const statusClass = trailer.status === 'loaded' ? 'loaded' : 'empty';
      return `
        <div class="yard-slot occupied ${trailer.status} ${highlightClass}" data-slot="${doorNumber}" data-slot-id="${slot?.id || ''}">
          <div class="yard-slot-number">${doorNumber}</div>
          <div class="slot-content">
            <div class="slot-trailer-row slot-customer-row">${trailer.customer || ''}</div>
            <div class="slot-trailer-row">
              <span class="trailer-carrier">${trailer.carrier}</span>
              <span class="yard-slot-status ${statusClass}" data-trailer-id="${trailer.id}">${statusText}</span>
            </div>
            <div class="trailer-number-row">${trailer.number ? trailer.number : ''}${trailer.loadNumber ? ` ‚Ä¢ ${trailer.loadNumber}` : ''}</div>
          </div>
          <button class="delete-trailer-btn" data-trailer-id="${trailer.id}" title="Delete trailer">üóëÔ∏è</button>
        </div>
      `;
    } else {
      return `
        <div class="yard-slot empty ${highlightClass} ${searchClass}" data-slot="${doorNumber}" data-door-id="${door.id}">
          <div class="yard-slot-number">${doorNumber}</div>
          <div class="slot-content">
            <span class="slot-empty-text">Empty - ${door.inService === false ? 'Door Out of Service' : 'Available'}</span>
          </div>
        </div>
      `;
    }
  }).join('');

  // Add drag and click listeners to occupied slots
  list.querySelectorAll('.yard-slot.occupied').forEach(slot => {
    const trailerId = slot.querySelector('.delete-trailer-btn')?.dataset.trailerId;
    const trailer = state.trailers.find(t => t.id === trailerId) || 
                    state.yardTrailers.find(t => t.id === trailerId);
    slot.setAttribute('draggable', 'true');
    slot.dataset.trailerId = trailerId;
    slot.style.cursor = 'pointer';
    
    // Click for selection
    slot.addEventListener('click', (e) => {
      if (isShiftPressed && !e.target.closest('.delete-trailer-btn') && !e.target.closest('.yard-slot-status')) {
        e.preventDefault();
        e.stopPropagation();
        toggleTrailerSelection(trailerId);
      }
    });
    
    // Double-click status badge to toggle
    const statusBadge = slot.querySelector('.yard-slot-status');
    if (statusBadge) {
      statusBadge.addEventListener('dblclick', async (e) => {
        e.stopPropagation();
        if (!trailer) return;
        
        const newStatus = trailer.status === 'loaded' ? 'empty' : 'loaded';
        try {
          await updateTrailer(trailerId, { status: newStatus });
          showToast(`Status changed to ${newStatus === 'loaded' ? 'üì¶ Loaded' : 'üì≠ Empty'}`, 'success');
          fetchState();
        } catch (error) {
          showToast(error.message, 'error');
        }
      });
    }
    
    // Double-click slot to edit (not on status badge or delete button)
    slot.addEventListener('dblclick', (e) => {
      if (!e.target.closest('.delete-trailer-btn') && 
          !e.target.closest('.yard-slot-status')) {
        openTrailerEditModal(trailerId);
      }
    });
    
    // Drag handlers
    slot.addEventListener('dragstart', (e) => {
      if (trailerId) {
        draggedTrailerId = trailerId;
        e.dataTransfer.setData('text/plain', trailerId);
        slot.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
      }
    });
    slot.addEventListener('dragend', (e) => {
      slot.classList.remove('dragging');
      draggedTrailerId = null;
      document.querySelectorAll('.drop-hover').forEach(el => el.classList.remove('drop-hover'));
    });
    
    if (selectedTrailers.has(trailerId)) {
      slot.classList.add('selected');
    }
  });

  // Add drop zone events to empty slots
  list.querySelectorAll('.yard-slot.empty').forEach(slot => {
    slot.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      slot.classList.add('drop-hover');
    });
    slot.addEventListener('dragleave', () => {
      slot.classList.remove('drop-hover');
    });
    slot.addEventListener('drop', async (e) => {
      e.preventDefault();
      slot.classList.remove('drop-hover');
      const trailerId = e.dataTransfer.getData('text/plain');
      if (!trailerId) return;

      const slotNum = parseInt(slot.dataset.slot);
      
      // Record position before move for undo
      const fromPos = getCurrentTrailerPosition(trailerId);
      
      let yardSlot = state.yardSlots.find(s => s.number === slotNum);
      if (!yardSlot) {
        try {
          const result = await createYardSlot({ number: slotNum });
          yardSlot = result.slot;
        } catch (error) {
          showToast('Failed to create yard slot', 'error');
          return;
        }
      }
      
      try {
        await moveToYardSlot(trailerId, yardSlot.id);
        recordLastAction('moveToSlot', trailerId, fromPos, { slotNum });
        showToast(`Moved to Yard Spot ${slotNum}`, 'success');
        fetchState();
      } catch (error) {
        showToast(error.message, 'error');
      }
    });
  });

  // Trailer delete buttons in slots
  list.querySelectorAll('.delete-trailer-btn').forEach(btn => {
    btn.addEventListener('click', async (e) => {
      e.stopPropagation();
      const trailerId = btn.dataset.trailerId;
      const trailer = state.trailers.find(t => t.id === trailerId) ||
                     state.yardTrailers.find(t => t.id === trailerId);
      if (!trailer) return;

      if (!confirm(`Delete trailer ${trailer.number} (${trailer.carrier})?\n\nThis will permanently remove it.`)) {
        return;
      }

      if (selectedTrailers.has(trailerId)) {
        selectedTrailers.delete(trailerId);
      }

      try {
        await deleteTrailer(trailerId);
        showToast('Trailer deleted', 'success');
        fetchState();
      } catch (error) {
        showToast(error.message, 'error');
      }
    });
  });
}

function getCurrentTrailerPosition(trailerId) {
  const trailer = state.trailers.find(t => t.id === trailerId) ||
                  state.yardTrailers.find(t => t.id === trailerId);
  if (!trailer) return { doorNum: null, slotNum: null, unassigned: true };
  
  if (trailer.doorNumber) return { doorNum: trailer.doorNumber, slotNum: null, unassigned: false };
  if (trailer.yardSlotNumber) return { doorNum: null, slotNum: trailer.yardSlotNumber, unassigned: false };
  return { doorNum: null, slotNum: null, unassigned: true };
}

function renderUnassignedYard() {
  const yard = document.getElementById('yard-area');
  const unassignedCount = document.getElementById('unassigned-count');
  if (unassignedCount) unassignedCount.textContent = state.yardTrailers.length;
  if (!yard) return;

  if (state.yardTrailers.length === 0) {
    yard.innerHTML = '<div class="yard-placeholder">Drop unassigned trailers here</div>';
  } else {
    yard.innerHTML = state.yardTrailers.map(t => {
      // Search match
      let searchClass = '';
      if (searchQuery) {
        if (isTrailerInSearchResults(t.id)) {
          searchClass = 'search-match';
        } else {
          searchClass = 'search-mismatch';
        }
      }
      
      // Determine highlight state for carrier filter
      let highlightClass = '';
      if (activeCarrierFilter) {
        if (t.carrier === activeCarrierFilter) {
          highlightClass = 'highlighted';
        } else {
          highlightClass = 'dimmed';
        }
      }
      
      // Selection state
      const selectedClass = selectedTrailers.has(t.id) ? 'selected' : '';
      
      const statusText = t.status === 'loaded' ? 'LOADED' : 'EMPTY';
      const statusClass = t.status === 'loaded' ? 'loaded' : 'empty';
      // Build info row with trailer number, load number (no dwell time in yard)
      let infoRow = '';
      if (t.number) infoRow += `<span class="trailer-number">${t.number}</span>`;
      if (t.loadNumber) infoRow += `<span class="trailer-load-number">${t.loadNumber}</span>`;
      
      return `
        <div class="yard-trailer ${t.status} ${highlightClass} ${searchClass} ${selectedClass}" draggable="true" data-trailer-id="${t.id}">
          <div class="yard-trailer-customer">${t.customer || ''}</div>
          <div class="yard-trailer-header">
            <span class="trailer-carrier">${t.carrier}</span>
            <span class="yard-status-badge ${statusClass}" data-trailer-id="${t.id}">${statusText}</span>
            <button class="delete-trailer-btn" data-trailer-id="${t.id}" title="Delete trailer">üóëÔ∏è</button>
          </div>
          ${infoRow ? `<div class="yard-trailer-info">${infoRow}</div>` : ''}
        </div>
      `;
    }).join('');
    
    // Add drag handlers to unassigned yard trailers
    yard.querySelectorAll('.yard-trailer[draggable]').forEach(el => {
      el.addEventListener('dragstart', handleDragStart);
      el.addEventListener('dragend', handleDragEnd);
      el.addEventListener('click', (e) => {
        // Shift+Click to select
        if (isShiftPressed && !e.target.closest('.delete-trailer-btn') && !e.target.closest('.yard-status-badge')) {
          e.preventDefault();
          e.stopPropagation();
          toggleTrailerSelection(el.dataset.trailerId);
        }
      });
    });
    
    // Double-click status badge to toggle
    yard.querySelectorAll('.yard-status-badge').forEach(badge => {
      badge.style.cursor = 'pointer';
      badge.addEventListener('dblclick', async (e) => {
        e.stopPropagation();
        const trailerId = badge.dataset.trailerId;
        const trailer = state.yardTrailers.find(t => t.id === trailerId);
        if (!trailer) return;
        
        const newStatus = trailer.status === 'loaded' ? 'empty' : 'loaded';
        try {
          await updateTrailer(trailerId, { status: newStatus });
          showToast(`Status changed to ${newStatus === 'loaded' ? 'üì¶ Loaded' : 'üì≠ Empty'}`, 'success');
          fetchState();
        } catch (error) {
          showToast(error.message, 'error');
        }
      });
    });
    
    // Double-click trailer to edit
    yard.querySelectorAll('.yard-trailer').forEach(el => {
      el.style.cursor = 'pointer';
      el.addEventListener('dblclick', (e) => {
        if (!e.target.closest('.delete-trailer-btn') && 
            !e.target.closest('.yard-status-badge')) {
          openTrailerEditModal(el.dataset.trailerId);
        }
      });
    });
    
    // Trailer delete buttons
    yard.querySelectorAll('.delete-trailer-btn').forEach(btn => {
      if (btn._handlerAttached) return;
      btn._handlerAttached = true;
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const trailerId = btn.dataset.trailerId;
        const trailer = state.yardTrailers.find(t => t.id === trailerId);
        if (!trailer) return;
        
        if (!confirm(`Delete trailer ${trailer.number} (${trailer.carrier})?\n\nThis will permanently remove it.`)) {
          return;
        }
        
        if (selectedTrailers.has(trailerId)) {
          selectedTrailers.delete(trailerId);
        }
        
        try {
          await deleteTrailer(trailerId);
          showToast('Trailer deleted', 'success');
          fetchState();
        } catch (error) {
          showToast(error.message, 'error');
        }
      });
    });
  }
}

function updateStats() {
  const occupied = state.trailers.filter(t => t.doorNumber).length;
  const occupiedCount = document.getElementById('occupied-count');
  const lastUpdate = document.getElementById('last-update');
  
  if (occupiedCount) occupiedCount.textContent = `Occupied: ${occupied}/57`;
  if (lastUpdate) lastUpdate.textContent = `Updated: ${new Date().toLocaleTimeString()}`;
}

function renderCarrierSelect() {
  const select = document.getElementById('carrier-select');
  if (!select) return;
  
  const favorites = state.carriers.filter(c => c.favorite).sort((a,b) => a.name.localeCompare(b.name));
  const others = state.carriers.filter(c => !c.favorite).sort((a,b) => a.name.localeCompare(b.name));
  
  let html = '<option value="">Select a carrier...</option>';
  
  if (favorites.length > 0) {
    html += '<optgroup label="‚≠ê Favorites">';
    favorites.forEach(c => html += `<option value="${c.name}">${c.name}</option>`);
    html += '</optgroup>';
  }
  
  if (others.length > 0) {
    html += '<optgroup label="All Carriers">';
    others.forEach(c => html += `<option value="${c.name}">${c.name}</option>`);
    html += '</optgroup>';
  }
  
  select.innerHTML = html;
}

// ============================================================================
// Carrier Summary Bar & Filtering
// ============================================================================

let activeCarrierFilter = null;

function renderCarrierSummary() {
  const container = document.getElementById('carrier-list');
  if (!container) return;
  
  // Get ALL trailers by carrier (dock + yard slots + unassigned)
  const carrierLocations = {};
  
  // Docked trailers
  state.trailers.forEach(t => {
    if (t.doorNumber) {
      if (!carrierLocations[t.carrier]) carrierLocations[t.carrier] = { doors: [], yardSlots: [], unassigned: 0 };
      carrierLocations[t.carrier].doors.push({ num: t.doorNumber, status: t.status });
    }
  });
  
  // Yard slot trailers
  state.yardSlots.forEach(slot => {
    if (slot.trailerId) {
      const trailer = state.trailers.find(t => t.id === slot.trailerId) || 
                      state.yardTrailers.find(t => t.id === slot.trailerId);
      if (trailer) {
        if (!carrierLocations[trailer.carrier]) carrierLocations[trailer.carrier] = { doors: [], yardSlots: [], unassigned: 0 };
        carrierLocations[trailer.carrier].yardSlots.push({ num: slot.number, status: trailer.status });
      }
    }
  });
  
  // Unassigned yard trailers
  state.yardTrailers.forEach(t => {
    if (!carrierLocations[t.carrier]) carrierLocations[t.carrier] = { doors: [], yardSlots: [], unassigned: 0 };
    carrierLocations[t.carrier].unassigned++;
  });
  
  const carriers = Object.keys(carrierLocations).sort();
  
  if (carriers.length === 0) {
    container.innerHTML = '<span class="no-carriers">No trailers</span>';
    return;
  }
  
  container.innerHTML = carriers.map(carrier => {
    const loc = carrierLocations[carrier];
    const isActive = activeCarrierFilter === carrier;
    
    // Build location text with status-colored numbers
    const parts = [];
    if (loc.doors.length > 0) {
      const doorText = loc.doors.sort((a,b) => a.num - b.num)
        .map(d => `<span class="loc-num ${d.status}">${d.num}</span>`).join(', ');
      parts.push(`Doors ${doorText}`);
    }
    if (loc.yardSlots.length > 0) {
      const yardText = loc.yardSlots.sort((a,b) => a.num - b.num)
        .map(s => `<span class="loc-num ${s.status}">Y${s.num}</span>`).join(', ');
      parts.push(`Yard ${yardText}`);
    }
    if (loc.unassigned > 0) {
      parts.push(`Unassigned √ó${loc.unassigned}`);
    }
    
    return `
      <span class="carrier-summary-item ${isActive ? 'active' : ''}" data-carrier="${carrier}">
        <span class="carrier-name">${carrier}</span>
        <span class="location-list">${parts.join(' ‚Ä¢ ')}</span>
      </span>
    `;
  }).join('');
  
  // Add click handlers for filtering
  container.querySelectorAll('.carrier-summary-item').forEach(item => {
    item.addEventListener('click', () => {
      const carrier = item.dataset.carrier;
      if (activeCarrierFilter === carrier) {
        activeCarrierFilter = null;
      } else {
        activeCarrierFilter = carrier;
      }
      renderDoors();
      renderYardSlots();
      renderUnassignedYard();
      renderCarrierSummary();
      if (activeCarrierFilter) {
        const loc = carrierLocations[carrier];
        const total = loc.doors.length + loc.yardSlots.length + loc.unassigned;
        showToast(`${carrier}: ${total} trailer${total > 1 ? 's' : ''} found`, 'info');
      }
    });
  });
}

// ============================================================================
// Drag and Drop
// ============================================================================

let draggedTrailerId = null;

function handleDragStart(e) {
  draggedTrailerId = e.target.dataset.trailerId;
  e.dataTransfer.setData('text/plain', draggedTrailerId);
  e.target.classList.add('dragging');
  e.dataTransfer.effectAllowed = 'move';
  console.log('Dragging trailer:', draggedTrailerId);
}

function handleDragEnd(e) {
  e.target.classList.remove('dragging');
  console.log('Drag ended, clearing trailer ID');
  draggedTrailerId = null;
  document.querySelectorAll('.drop-hover').forEach(el => el.classList.remove('drop-hover'));
}

function handleDragOver(e) {
  e.preventDefault();
  e.dataTransfer.dropEffect = 'move';
  const door = e.target.closest('.dock-door');
  if (door && !door.classList.contains('occupied')) {
    door.classList.add('drop-hover');
  }
}

function handleDragLeave(e) {
  const door = e.target.closest('.dock-door');
  if (door) door.classList.remove('drop-hover');
  const yard = e.target.closest('#yard-area');
  if (yard) yard.classList.remove('drop-hover');
}

async function handleDrop(e) {
  e.preventDefault();
  const door = e.target.closest('.dock-door');
  if (!door) return;
  
  door.classList.remove('drop-hover');
  
  if (door.classList.contains('occupied')) {
    showToast('Door is already occupied!', 'error');
    return;
  }

  const doorNum = parseInt(door.dataset.door);
  const trailerId = e.dataTransfer.getData('text/plain') || draggedTrailerId;
  if (!trailerId) return;
  
  // Record position before move for undo
  const fromPos = getCurrentTrailerPosition(trailerId);
  
  try {
    await moveToDoor(trailerId, doorNum);
    recordLastAction('moveToDoor', trailerId, fromPos, { doorNum });
    showToast(`Moved to Door ${doorNum}`, 'success');
    await fetchState();
  } catch (error) {
    showToast(error.message, 'error');
  }
}

async function handleDropToYard(e) {
  e.preventDefault();
  console.log('Drop to yard, trailerId:', draggedTrailerId);
  e.currentTarget.classList.remove('drop-hover');
  
  const trailerId = e.dataTransfer.getData('text/plain') || draggedTrailerId;
  if (!trailerId) {
    console.log('No trailer ID, aborting');
    return;
  }
  
  // Find which door this trailer is in
  const trailer = state.trailers.find(t => t.id === trailerId);
  const doorId = trailer?.doorNumber;
  
  // Record position before move for undo
  const fromPos = getCurrentTrailerPosition(trailerId);
  
  try {
    await moveToYard(trailerId, doorId);
    recordLastAction('moveToYard', trailerId, fromPos, { unassigned: true });
    showToast('Moved to yard', 'success');
    await fetchState();
  } catch (error) {
    showToast(error.message, 'error');
  }
}

// ============================================================================
// Modal Handling
// ============================================================================

function openModal(id) {
  const modal = document.getElementById(id);
  if (modal) {
    modal.style.display = 'flex';
    modal.classList.add('active');
  }
}

function closeModal(id) {
  const modal = document.getElementById(id);
  if (modal) {
    modal.style.display = 'none';
    modal.classList.remove('active');
  }
}

function setupModals() {
  // Close buttons
  document.querySelectorAll('.close-modal, .modal-close, .modal-cancel').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const modal = e.target.closest('.modal');
      if (modal) closeModal(modal.id);
    });
  });

  // Backdrop click
  document.querySelectorAll('.modal').forEach(modal => {
    modal.addEventListener('click', (e) => {
      if (e.target === modal) closeModal(modal.id);
    });
  });

  // Main buttons
  document.getElementById('btn-create-trailer')?.addEventListener('click', () => {
    document.getElementById('quick-add-panel')?.classList.remove('hidden');
    document.getElementById('form-create-trailer')?.classList.add('hidden');
    renderQuickCarrierButtons();
    openModal('modal-create');
  });
  
  document.getElementById('btn-view-history')?.addEventListener('click', () => {
    openModal('modal-history');
    loadHistory();
  });
  
  document.getElementById('btn-analytics')?.addEventListener('click', () => {
    showAnalyticsModal();
  });
  
  document.getElementById('btn-manage-carriers')?.addEventListener('click', () => {
    openModal('modal-carriers');
    renderCarriersList();
  });
  
  // Undo button
  document.getElementById('btn-undo')?.addEventListener('click', () => {
    undoLastAction();
  });
  
  // Clear search button
  document.getElementById('btn-clear-search')?.addEventListener('click', () => {
    clearSearch();
  });
  
  // Show/hide clear button based on search input
  const searchInput = document.getElementById('search-input');
  const clearBtn = document.getElementById('btn-clear-search');
  if (searchInput && clearBtn) {
    searchInput.addEventListener('input', (e) => {
      if (e.target.value) {
        clearBtn.classList.remove('hidden');
      } else {
        clearBtn.classList.add('hidden');
      }
    });
  }
  
  // Bulk move to yard
  document.getElementById('btn-bulk-move-to-yard')?.addEventListener('click', () => {
    bulkMoveToYard();
  });
  
  // Clear selection
  document.getElementById('btn-clear-selection')?.addEventListener('click', () => {
    clearSelection();
  });

  // Quick Add Toggle
  document.getElementById('btn-show-full-form')?.addEventListener('click', () => {
    document.getElementById('quick-add-panel')?.classList.add('hidden');
    document.getElementById('form-create-trailer')?.classList.remove('hidden');
    document.getElementById('carrier-input').focus();
  });
  
  document.getElementById('btn-cancel-full')?.addEventListener('click', () => {
    document.getElementById('form-create-trailer')?.classList.add('hidden');
    document.getElementById('quick-add-panel')?.classList.remove('hidden');
    renderQuickCarrierButtons();
  });

  // Quick Add Custom Carrier
  document.getElementById('btn-quick-add')?.addEventListener('click', async () => {
    const carrierInput = document.getElementById('quick-carrier-input');
    const targetDoor = document.getElementById('form-create-trailer')?.dataset.targetDoor;
    
    const carrier = carrierInput?.value.trim();
    if (!carrier) {
      showToast('Please enter a carrier name', 'warning');
      return;
    }

    try {
      const result = await createTrailer({
        carrier: carrier,
        status: 'empty'
      });
      
      const trailerId = result.trailer?.id;
      
      if (targetDoor && trailerId) {
        await moveToDoor(trailerId, parseInt(targetDoor));
        showToast(`‚úÖ ${carrier} trailer added to Door ${targetDoor}!`, 'success');
      } else {
        showToast(`‚úÖ ${carrier} trailer added to yard!`, 'success');
      }
      
      closeModal('modal-create');
      carrierInput.value = '';
      delete document.getElementById('form-create-trailer').dataset.targetDoor;
      await fetchState();
    } catch (error) {
      showToast(error.message, 'error');
    }
  });

  // Quick carrier input Enter key
  document.getElementById('quick-carrier-input')?.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      document.getElementById('btn-quick-add')?.click();
    }
  });

  // Create trailer form
  document.getElementById('form-create-trailer')?.addEventListener('submit', async (e) => {
    e.preventDefault();
    const form = e.target;
    const targetDoor = form.dataset.targetDoor;
    
    const data = {
      number: document.getElementById('trailer-number')?.value || null,
      carrier: document.getElementById('carrier-input')?.value,
      status: document.getElementById('load-type')?.value,
      customer: document.getElementById('trailer-customer')?.value || null,
      loadNumber: document.getElementById('load-number')?.value || null,
      contents: document.getElementById('notes')?.value
    };
    
    try {
      const result = await createTrailer(data);
      const trailerId = result.trailer?.id;
      
      if (targetDoor && trailerId) {
        await moveToDoor(trailerId, parseInt(targetDoor));
        showToast(`Trailer placed in Door ${targetDoor}!`, 'success');
      } else {
        showToast('Trailer created!', 'success');
      }
      
      closeModal('modal-create');
      form.reset();
      document.getElementById('quick-add-panel')?.classList.remove('hidden');
      form.classList.add('hidden');
      delete form.dataset.targetDoor;
      await fetchState();
    } catch (error) {
      showToast(error.message, 'error');
    }
  });

  // Yard drop zone
  const yard = document.getElementById('yard-area');
  if (yard) {
    yard.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      yard.classList.add('drop-hover');
    });
    yard.addEventListener('drop', (e) => {
      e.preventDefault();
      yard.classList.remove('drop-hover');
      handleDropToYard(e);
    });
    yard.addEventListener('dragleave', (e) => {
      if (!yard.contains(e.relatedTarget)) {
        yard.classList.remove('drop-hover');
      }
    });
  }

  // Grid drop zones
  const grid = document.getElementById('dock-grid');
  if (grid) {
    grid.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      const door = e.target.closest('.dock-door');
      if (door && !door.classList.contains('occupied')) {
        door.classList.add('drop-hover');
      }
    });
    grid.addEventListener('dragleave', (e) => {
      const door = e.target.closest('.dock-door');
      if (door) door.classList.remove('drop-hover');
    });
    grid.addEventListener('drop', (e) => {
      e.preventDefault();
      const door = e.target.closest('.dock-door');
      if (!door) return;
      door.classList.remove('drop-hover');
      
      if (door.classList.contains('occupied')) {
        showToast('Door is already occupied!', 'error');
        return;
      }

      const doorNum = parseInt(door.dataset.door);
      const trailerId = e.dataTransfer.getData('text/plain');
      
      if (!trailerId) {
        // If multiple selected and dropping to empty door
        if (selectedTrailers.size > 0) {
          const firstTrailer = Array.from(selectedTrailers)[0];
          moveToDoor(firstTrailer, doorNum)
            .then(() => {
              recordLastAction('moveToDoor', firstTrailer, getCurrentTrailerPosition(firstTrailer), { doorNum });
              showToast(`Moved to Door ${doorNum}`, 'success');
              if (selectedTrailers.size > 1) {
                showToast(`Note: Only moved one trailer. Use bulk move for multiple.`, 'warning');
              }
              clearSelection();
              fetchState();
            })
            .catch(error => showToast(error.message, 'error'));
        }
        return;
      }
      
      // Record position before move for undo
      const fromPos = getCurrentTrailerPosition(trailerId);
      
      moveToDoor(trailerId, doorNum)
        .then(() => {
          recordLastAction('moveToDoor', trailerId, fromPos, { doorNum });
          showToast(`Moved to Door ${doorNum}`, 'success');
          fetchState();
        })
        .catch(error => showToast(error.message, 'error'));
    });
  }

  // Carrier autocomplete
  setupCarrierAutocomplete();

  // History search with clear button
  const historySearch = document.getElementById('history-search');
  let searchDebounce;
  historySearch?.addEventListener('input', (e) => {
    clearTimeout(searchDebounce);
    searchDebounce = setTimeout(() => loadHistory(e.target.value), 300);
  });
  
  document.getElementById('history-clear')?.addEventListener('click', () => {
    if (historySearch) {
      historySearch.value = '';
      loadHistory('');
    }
  });
  
  // Date filters
  const dateFrom = document.getElementById('history-date-from');
  const dateTo = document.getElementById('history-date-to');
  
  dateFrom?.addEventListener('change', () => loadHistory(historySearch?.value || ''));
  dateTo?.addEventListener('change', () => loadHistory(historySearch?.value || ''));
  
  document.getElementById('history-date-clear')?.addEventListener('click', () => {
    if (dateFrom) dateFrom.value = '';
    if (dateTo) dateTo.value = '';
    loadHistory(historySearch?.value || '');
  });

  // Carrier search
  const carrierSearch = document.getElementById('carrier-search');
  carrierSearch?.addEventListener('input', (e) => {
    renderCarriersList(e.target.value);
  });
  
  // Main search input
  const mainSearch = document.getElementById('search-input');
  let mainSearchDebounce;
  mainSearch?.addEventListener('input', (e) => {
    clearTimeout(mainSearchDebounce);
    mainSearchDebounce = setTimeout(() => performSearch(e.target.value), 300);
  });
  
  // Enter key opens search results modal
  mainSearch?.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      showSearchResultsModal();
    }
  });
}

// ============================================================================
// History & Carriers
// ============================================================================

async function loadHistory(search = '') {
  const list = document.getElementById('history-list');
  const emptyMsg = document.getElementById('history-empty');
  if (!list) return;
  
  try {
    const dateFrom = document.getElementById('history-date-from')?.value;
    const dateTo = document.getElementById('history-date-to')?.value;
    
    const data = await getHistory(search, 100, 0, dateFrom, dateTo);
    if (data.entries.length === 0) {
      list.innerHTML = '';
      if (emptyMsg) emptyMsg.classList.remove('hidden');
      return;
    }
    
    if (emptyMsg) emptyMsg.classList.add('hidden');
    
    list.innerHTML = data.entries.map(h => {
      // Determine action styling and label
      let actionClass = 'updated';
      let actionLabel = 'Updated';
      
      if (h.action?.includes('CREATED')) { actionClass = 'created'; actionLabel = 'Created'; }
      else if (h.action?.includes('MOVED')) { actionClass = 'moved'; actionLabel = 'Moved'; }
      else if (h.action?.includes('DELETED')) { actionClass = 'deleted'; actionLabel = 'Deleted'; }
      else if (h.action === 'TRAILER_LOADED') { actionClass = 'loaded'; actionLabel = 'Loaded'; }
      else if (h.action === 'TRAILER_EMPTY') { actionClass = 'empty'; actionLabel = 'Empty'; }
      
      // Get carrier from various sources (backwards compatible)
      const carrier = h.carrier || (h.updates?.carrier);
      const trailerNumber = h.trailerNumber || (h.updates?.number);
      
      // Build trailer identifier: "Carrier trailer" or "Carrier trailer 12345"
      let trailerIdText = carrier && trailerNumber 
        ? `${carrier} trailer ${trailerNumber}`
        : carrier 
          ? `${carrier} trailer`
          : 'Trailer';
      
      // Get location
      const atLocation = h.location || h.previousLocation || (h.doorNumber ? `Door ${h.doorNumber}` : '');
      
      // For TRAILER_UPDATED, build the change description
      let changeDesc = '';
      if (h.action === 'TRAILER_UPDATED' && h.changes?.length > 0) {
        const fieldLabels = {
          number: 'trailer number',
          loadNumber: 'load number',
          customer: 'customer',
          carrier: 'carrier',
          contents: 'notes',
          status: 'status'
        };
        const change = h.changes[0];
        const label = fieldLabels[change.field] || change.field;
        
        if (!change.from) {
          changeDesc = `added ${label} ${change.to}`;
        } else if (!change.to) {
          changeDesc = `removed ${label}`;
        } else {
          changeDesc = `changed ${label} ${change.from} ‚Üí ${change.to}`;
        }
      } else if (h.action === 'TRAILER_UPDATED' && h.updates) {
        // Fallback for old entries without changes array
        const updatedFields = Object.keys(h.updates).filter(k => k !== 'carrier' && k !== 'status');
        if (updatedFields.length > 0) {
          const fieldLabels = {
            number: 'trailer number',
            loadNumber: 'load number',
            customer: 'customer',
            contents: 'notes'
          };
          const fields = updatedFields.map(f => fieldLabels[f] || f).join(', ');
          changeDesc = `updated ${fields}`;
        } else if (h.updates.status) {
          changeDesc = `marked ${h.updates.status}`;
        }
      }
      
      // Build location line with arrows for movements
      let locationHtml = '';
      if (h.action?.includes('MOVED')) {
        const from = h.previousLocation || 'Yard';
        const to = h.toLocation || (h.doorNumber ? `Door ${h.doorNumber}` : h.yardSlotNumber ? `Yard Spot ${h.yardSlotNumber}` : 'Yard');
        locationHtml = `
          <div class="history-location">
            <span class="history-location-from">${from}</span>
            <span class="history-location-arrow">‚Üí</span>
            <span class="history-location-to">${to}</span>
          </div>
        `;
      }
      
      return `
      <div class="history-item" data-trailer-id="${h.trailerId || ''}" title="Double-click to edit trailer">
        <div class="history-item-header">
          <span class="history-action ${actionClass}">${actionLabel}</span>
          <span class="history-time">${new Date(h.timestamp).toLocaleString()}</span>
        </div>
        <div class="history-trailer-info">
          ${trailerNumber ? `<span class="history-trailer-number">${trailerNumber}</span>` : ''}
          ${carrier ? `<span class="history-carrier">${carrier}</span>` : ''}
        </div>
        ${atLocation ? `<div class="history-location">üìç ${atLocation}</div>` : ''}
        ${locationHtml}
        ${changeDesc ? `<div class="history-change">${changeDesc}</div>` : ''}
      </div>
    `}).join('');
    
    // Add double-click handlers to history items
    list.querySelectorAll('.history-item[data-trailer-id]').forEach(item => {
      item.addEventListener('dblclick', () => {
        const trailerId = item.dataset.trailerId;
        if (trailerId) {
          // Find the trailer in current state
          const trailer = state.trailers.find(t => t.id === trailerId) || 
                         state.yardTrailers.find(t => t.id === trailerId);
          if (trailer) {
            openTrailerEditModal(trailerId);
          } else {
            showToast('Trailer no longer exists', 'warning');
          }
        }
      });
    });
    
  } catch (error) {
    console.error('History load error:', error);
    list.innerHTML = '<div class="history-empty">Failed to load history</div>';
  }
}

function renderCarriersList(search = '') {
  const favoritesContainer = document.getElementById('favorite-carriers');
  const allContainer = document.getElementById('all-carriers');
  
  let carriers = state.carriers;
  if (search) {
    carriers = carriers.filter(c => c.name.toLowerCase().includes(search.toLowerCase()));
  }
  
  const favorites = carriers.filter(c => c.favorite).sort((a,b) => a.name.localeCompare(b.name));
  const others = carriers.filter(c => !c.favorite).sort((a,b) => a.name.localeCompare(b.name));
  
  const renderCarrier = (c) => `
    <div class="carrier-item">
      <span class="carrier-name">${c.name}${c.mcNumber ? ` (${c.mcNumber})` : ''}</span>
      <div class="carrier-actions">
        <button class="btn-favorite" data-carrier="${c.id}">${c.favorite ? '‚≠ê' : '‚òÜ'}</button>
        ${editMode ? `<button class="btn-delete-carrier" data-carrier="${c.id}" title="Delete carrier">üóëÔ∏è</button>` : ''}
      </div>
    </div>
  `;
  
  if (favoritesContainer) favoritesContainer.innerHTML = favorites.map(renderCarrier).join('');
  if (allContainer) allContainer.innerHTML = others.map(renderCarrier).join('');
  
  document.querySelectorAll('.btn-favorite').forEach(btn => {
    btn.addEventListener('click', async (e) => {
      const carrierId = e.target.dataset.carrier;
      const carrier = state.carriers.find(c => c.id === carrierId);
      if (carrier) {
        try {
          await apiCall(`/carriers/${carrierId}/favorite`, 'PUT', { favorite: !carrier.favorite });
          await fetchState();
          renderCarriersList(search);
        } catch (err) {
          showToast(err.message, 'error');
        }
      }
    });
  });
  
  // Delete carrier handler
  document.querySelectorAll('.btn-delete-carrier').forEach(btn => {
    btn.addEventListener('click', async (e) => {
      const carrierId = e.target.dataset.carrier;
      const carrier = state.carriers.find(c => c.id === carrierId);
      if (!carrier) return;
      
      // Check if carrier is in use
      const inUse = state.trailers.some(t => t.carrier === carrier.name) || 
                    state.yardTrailers.some(t => t.carrier === carrier.name);
      if (inUse) {
        showToast('Cannot delete: carrier is assigned to trailers', 'error');
        return;
      }
      
      if (!confirm(`Delete carrier "${carrier.name}"?`)) return;
      
      try {
        await apiCall(`/carriers/${carrierId}`, 'DELETE');
        await fetchState();
        renderCarriersList(search);
        showToast('Carrier deleted', 'success');
      } catch (err) {
        showToast(err.message, 'error');
      }
    });
  });
}

// ============================================================================
// Input Sanitization
// ============================================================================

function sanitizeInput(value) {
  if (!value) return '';
  // Only allow: English letters (a-z, A-Z), numbers (0-9), dash, underscore, space
  return value.replace(/[^a-zA-Z0-9_\-\s]/g, '');
}

function setupInputSanitization(inputElement) {
  if (!inputElement) return;
  
  inputElement.addEventListener('input', (e) => {
    const sanitized = sanitizeInput(e.target.value);
    if (sanitized !== e.target.value) {
      e.target.value = sanitized;
    }
  });
}

// Carrier Autocomplete
// ============================================================================

function setupCarrierAutocomplete(inputId = 'carrier-input', suggestionsId = 'carrier-suggestions') {
  const input = document.getElementById(inputId);
  const suggestions = document.getElementById(suggestionsId);
  
  if (!input) return;
  
  // Setup sanitization on the input
  setupInputSanitization(input);
  
  if (!suggestions) return;
  
  input.addEventListener('input', (e) => {
    const value = e.target.value.toLowerCase();
    if (value.length < 1) {
      suggestions.innerHTML = '';
      return;
    }
    
    const matches = state.carriers
      .filter(c => c.name.toLowerCase().includes(value))
      .sort((a, b) => {
        const aStarts = a.name.toLowerCase().startsWith(value) ? 0 : 1;
        const bStarts = b.name.toLowerCase().startsWith(value) ? 0 : 1;
        if (aStarts !== bStarts) return aStarts - bStarts;
        return a.name.localeCompare(b.name);
      })
      .slice(0, 5);
    
    if (matches.length === 0) {
      suggestions.innerHTML = '<div class="autocomplete-item">No carriers found</div>';
      return;
    }
    
    suggestions.innerHTML = matches.map(c => {
      const highlighted = c.name.replace(
        new RegExp(value, 'gi'),
        match => `<strong>${match}</strong>`
      );
      return `<div class="autocomplete-item" data-name="${c.name}">${highlighted}</div>`;
    }).join('');
    
    suggestions.querySelectorAll('.autocomplete-item').forEach(item => {
      item.addEventListener('click', () => {
        input.value = item.dataset.name;
        suggestions.innerHTML = '';
      });
    });
  });
  
  input.addEventListener('blur', () => {
    setTimeout(() => {
      suggestions.innerHTML = '';
    }, 200);
  });
  
  input.addEventListener('focus', () => {
    if (input.value.length > 0) {
      input.dispatchEvent(new Event('input'));
    }
  });
}

// Setup carrier autocomplete for edit modal
function setupEditModalCarrierAutocomplete() {
  const input = document.getElementById('edit-trailer-carrier');
  const suggestions = document.getElementById('edit-carrier-suggestions');
  
  if (!input || !suggestions) return;
  
  input.addEventListener('input', (e) => {
    const value = e.target.value.toLowerCase();
    if (value.length < 1) {
      suggestions.innerHTML = '';
      return;
    }
    
    const matches = state.carriers
      .filter(c => c.name.toLowerCase().includes(value))
      .sort((a, b) => {
        const aStarts = a.name.toLowerCase().startsWith(value) ? 0 : 1;
        const bStarts = b.name.toLowerCase().startsWith(value) ? 0 : 1;
        if (aStarts !== bStarts) return aStarts - bStarts;
        return a.name.localeCompare(b.name);
      })
      .slice(0, 5);
    
    if (matches.length === 0) {
      suggestions.innerHTML = '<div class="autocomplete-item">No carriers found</div>';
      return;
    }
    
    suggestions.innerHTML = matches.map(c => {
      const highlighted = c.name.replace(
        new RegExp(value, 'gi'),
        match => `<strong>${match}</strong>`
      );
      return `<div class="autocomplete-item" data-name="${c.name}">${highlighted}</div>`;
    }).join('');
    
    suggestions.querySelectorAll('.autocomplete-item').forEach(item => {
      item.addEventListener('click', () => {
        input.value = item.dataset.name;
        suggestions.innerHTML = '';
      });
    });
  });
  
  input.addEventListener('blur', () => {
    setTimeout(() => {
      suggestions.innerHTML = '';
    }, 200);
  });
  
  input.addEventListener('focus', () => {
    if (input.value.length > 0) {
      input.dispatchEvent(new Event('input'));
    }
  });
}

// ============================================================================
// Door Edit Modal
// ============================================================================

function openDoorEditor(doorId) {
  const door = state.doors.find(d => d.id === doorId);
  if (!door) return;
  
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.id = 'modal-door-edit';
  modal.innerHTML = `
    <div class="modal-content">
      <div class="modal-header">
        <h3>‚öôÔ∏è Edit Door</h3>
        <button class="close-modal">√ó</button>
      </div>
      <div class="modal-body">
        <!-- Door Type Selection -->
        <div class="door-type-section" style="margin-bottom:1.5rem; display:block !important;">
          <label class="section-label" style="display:block; font-size:0.875rem; font-weight:600; color:var(--text-secondary); margin-bottom:0.75rem; text-transform:uppercase; letter-spacing:0.05em;">Door Type</label>
          <div class="door-type-options" style="display:grid; grid-template-columns:repeat(3, 1fr); gap:0.75rem;">
            <button type="button" class="door-type-btn ${door.type !== 'blank' && door.inService !== false ? 'active' : ''}" data-type="normal" style="display:flex; flex-direction:column; align-items:center; gap:0.5rem; padding:1rem; background:var(--bg-tertiary); border:2px solid ${door.type !== 'blank' && door.inService !== false ? 'var(--accent-primary)' : 'var(--border-color)'}; border-radius:var(--radius-md); cursor:pointer; color:var(--text-secondary);">
              <span class="btn-icon" style="font-size:1.5rem;">üö™</span>
              <span class="btn-label" style="font-size:0.75rem; font-weight:600; text-align:center;">Normal<br><small style="font-weight:400; opacity:0.7;">Active door</small></span>
            </button>
            <button type="button" class="door-type-btn ${door.type === 'blank' ? 'active' : ''}" data-type="blank" style="display:flex; flex-direction:column; align-items:center; gap:0.5rem; padding:1rem; background:var(--bg-tertiary); border:2px solid ${door.type === 'blank' ? 'var(--accent-primary)' : 'var(--border-color)'}; border-radius:var(--radius-md); cursor:pointer; color:var(--text-secondary);">
              <span class="btn-icon" style="font-size:1.5rem;">‚¨ú</span>
              <span class="btn-label" style="font-size:0.75rem; font-weight:600; text-align:center;">Blank<br><small style="font-weight:400; opacity:0.7;">Placeholder</small></span>
            </button>
            <button type="button" class="door-type-btn ${door.inService === false ? 'active' : ''}" data-type="out-of-service" style="display:flex; flex-direction:column; align-items:center; gap:0.5rem; padding:1rem; background:var(--bg-tertiary); border:2px solid ${door.inService === false ? 'var(--accent-primary)' : 'var(--border-color)'}; border-radius:var(--radius-md); cursor:pointer; color:var(--text-secondary);">
              <span class="btn-icon" style="font-size:1.5rem;">üîß</span>
              <span class="btn-label" style="font-size:0.75rem; font-weight:600; text-align:center;">Out of Service<br><small style="font-weight:400; opacity:0.7;">Disabled</small></span>
            </button>
          </div>
        </div>
        
        <!-- Door Label -->
        <div class="form-group">
          <label class="section-label">Door Label</label>
          <div class="door-label-options">
            <label class="radio-label">
              <input type="radio" name="label-type" value="number" ${!door.labelText ? 'checked' : ''}>
              <span>Number</span>
            </label>
            <label class="radio-label">
              <input type="radio" name="label-type" value="text" ${door.labelText ? 'checked' : ''}>
              <span>Custom Text</span>
            </label>
          </div>
          <input type="number" id="door-number" value="${door.number}" class="${door.labelText ? 'hidden' : ''}">
          <input type="text" id="door-label-text" value="${door.labelText || ''}" placeholder="e.g. RAMP" class="${!door.labelText ? 'hidden' : ''}" maxlength="10">
        </div>
        
        <div class="modal-actions">
          <button id="btn-save-door" class="btn btn-primary">üíæ Save Changes</button>
          ${state.doors.length > 1 ? `<button id="btn-delete-door" class="btn btn-danger">üóëÔ∏è Delete Door</button>` : ''}
          <button class="btn btn-secondary close-modal">Cancel</button>
        </div>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // Setup type buttons
  let selectedType = door.type === 'blank' ? 'blank' : (door.inService === false ? 'out-of-service' : 'normal');
  
  function updateTypeButtonStyles() {
    modal.querySelectorAll('.door-type-btn').forEach(btn => {
      const isActive = btn.dataset.type === selectedType;
      btn.classList.toggle('active', isActive);
      btn.style.borderColor = isActive ? 'var(--accent-primary)' : 'var(--border-color)';
      btn.style.background = isActive ? 'rgba(59, 130, 246, 0.1)' : 'var(--bg-tertiary)';
    });
  }
  
  updateTypeButtonStyles();
  
  modal.querySelectorAll('.door-type-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      selectedType = btn.dataset.type;
      updateTypeButtonStyles();
    });
  });
  
  // Setup label type toggle
  const numberInput = document.getElementById('door-number');
  const textInput = document.getElementById('door-label-text');
  modal.querySelectorAll('input[name="label-type"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
      if (e.target.value === 'number') {
        numberInput.classList.remove('hidden');
        textInput.classList.add('hidden');
      } else {
        numberInput.classList.add('hidden');
        textInput.classList.remove('hidden');
        textInput.focus();
      }
    });
  });
  
  // Sanitize text input
  setupInputSanitization(textInput);
  
  modal.querySelectorAll('.close-modal').forEach(btn => {
    btn.addEventListener('click', () => modal.remove());
  });
  
  document.getElementById('btn-save-door')?.addEventListener('click', async () => {
    const useTextLabel = document.querySelector('input[name="label-type"]:checked')?.value === 'text';
    const labelText = useTextLabel ? document.getElementById('door-label-text')?.value?.trim() : null;
    const number = parseInt(document.getElementById('door-number')?.value) || door.number;
    
    const updates = {
      inService: selectedType !== 'out-of-service',
      type: selectedType === 'blank' ? 'blank' : 'normal',
      number,
      labelText: labelText || null
    };
    
    try {
      await updateDoor(doorId, updates);
      showToast('Door updated', 'success');
      modal.remove();
      fetchState();
    } catch (error) {
      showToast(error.message, 'error');
    }
  });
  
  document.getElementById('btn-delete-door')?.addEventListener('click', async () => {
    if (!confirm(`Delete Door ${door.number}?\n\nThis will remove the door and move any trailer to the yard.`)) {
      return;
    }
    
    try {
      await deleteDoor(doorId);
      showToast('Door deleted', 'success');
      modal.remove();
      fetchState();
    } catch (error) {
      showToast(error.message, 'error');
    }
  });
}

function openAddDoorModal() {
  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.id = 'modal-add-door';
  
  let selectedType = 'normal'; // default
  
  modal.innerHTML = `
    <div class="modal-content">
      <div class="modal-header">
        <h3>‚ûï Add New Door</h3>
        <button class="close-modal">√ó</button>
      </div>
      <div class="modal-body">
        <!-- Door Type Selection -->
        <div class="door-type-section" style="margin-bottom:1rem;">
          <label style="display:block; font-size:0.875rem; font-weight:600; color:var(--text-secondary); margin-bottom:0.5rem;">Door Type</label>
          <div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:0.5rem;">
            <button type="button" class="new-door-type-btn active" data-type="normal" style="display:flex; flex-direction:column; align-items:center; gap:0.25rem; padding:0.75rem; background:var(--bg-tertiary); border:2px solid var(--accent-primary); border-radius:var(--radius-md); cursor:pointer;">
              <span style="font-size:1.25rem;">üö™</span>
              <span style="font-size:0.6875rem; font-weight:600;">Normal</span>
            </button>
            <button type="button" class="new-door-type-btn" data-type="blank" style="display:flex; flex-direction:column; align-items:center; gap:0.25rem; padding:0.75rem; background:var(--bg-tertiary); border:2px solid var(--border-color); border-radius:var(--radius-md); cursor:pointer;">
              <span style="font-size:1.25rem;">‚¨ú</span>
              <span style="font-size:0.6875rem; font-weight:600;">Blank</span>
            </button>
            <button type="button" class="new-door-type-btn" data-type="out-of-service" style="display:flex; flex-direction:column; align-items:center; gap:0.25rem; padding:0.75rem; background:var(--bg-tertiary); border:2px solid var(--border-color); border-radius:var(--radius-md); cursor:pointer;">
              <span style="font-size:1.25rem;">üîß</span>
              <span style="font-size:0.6875rem; font-weight:600;">Out of Service</span>
            </button>
          </div>
        </div>
        
        <!-- Label Type -->
        <div style="margin-bottom:1rem;">
          <label style="display:block; font-size:0.875rem; font-weight:600; color:var(--text-secondary); margin-bottom:0.5rem;">Door Label</label>
          <div style="display:flex; gap:1rem; margin-bottom:0.5rem;">
            <label style="display:flex; align-items:center; gap:0.25rem; cursor:pointer;">
              <input type="radio" name="add-door-label-type" value="number" checked>
              <span>Number</span>
            </label>
            <label style="display:flex; align-items:center; gap:0.25rem; cursor:pointer;">
              <input type="radio" name="add-door-label-type" value="text">
              <span>Custom Text</span>
            </label>
          </div>
          <div id="add-door-number-input">
            <input type="number" id="new-door-number" placeholder="e.g., 58" style="width:100%; padding:0.5rem; background:var(--bg-primary); border:1px solid var(--border-color); border-radius:var(--radius-sm); color:var(--text-primary);">
          </div>
          <div id="add-door-text-input" style="display:none;">
            <input type="text" id="new-door-label-text" placeholder="e.g., RAMP" maxlength="10" style="width:100%; padding:0.5rem; background:var(--bg-primary); border:1px solid var(--border-color); border-radius:var(--radius-sm); color:var(--text-primary);">
          </div>
        </div>
        
        <div class="modal-actions">
          <button id="btn-create-door" class="btn btn-primary">‚ûï Create Door</button>
          <button class="btn btn-secondary close-modal">Cancel</button>
        </div>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // Setup type buttons
  modal.querySelectorAll('.new-door-type-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      modal.querySelectorAll('.new-door-type-btn').forEach(b => {
        b.classList.remove('active');
        b.style.borderColor = 'var(--border-color)';
      });
      btn.classList.add('active');
      btn.style.borderColor = 'var(--accent-primary)';
      selectedType = btn.dataset.type;
    });
  });
  
  // Setup label type toggle
  const numberInputDiv = document.getElementById('add-door-number-input');
  const textInputDiv = document.getElementById('add-door-text-input');
  
  modal.querySelectorAll('input[name="add-door-label-type"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
      if (e.target.value === 'number') {
        numberInputDiv.style.display = 'block';
        textInputDiv.style.display = 'none';
      } else {
        numberInputDiv.style.display = 'none';
        textInputDiv.style.display = 'block';
        document.getElementById('new-door-label-text')?.focus();
      }
    });
  });
  
  modal.querySelectorAll('.close-modal').forEach(btn => {
    btn.addEventListener('click', () => modal.remove());
  });
  
  document.getElementById('btn-create-door')?.addEventListener('click', async () => {
    const useTextLabel = document.querySelector('input[name="add-door-label-type"]:checked')?.value === 'text';
    const labelText = useTextLabel ? document.getElementById('new-door-label-text')?.value?.trim() : null;
    const number = parseInt(document.getElementById('new-door-number')?.value);
    
    if (useTextLabel && !labelText) {
      showToast('Please enter a label text', 'warning');
      return;
    }
    if (!useTextLabel && !number) {
      showToast('Please enter a door number', 'warning');
      return;
    }
    
    const doorData = { 
      number: useTextLabel ? 0 : number, // Assign 0 if using text label
      labelText: labelText,
      type: selectedType,
      inService: selectedType !== 'out-of-service'
    };
    
    try {
      await createDoor(doorData);
      showToast(labelText ? `Door "${labelText}" created!` : `Door ${number} created!`, 'success');
      modal.remove();
      fetchState();
    } catch (error) {
      showToast(error.message, 'error');
    }
  });
}

// ============================================================================
// Trailer Edit Modal (Enhanced with Timeline)
// ============================================================================

function openTrailerEditModal(trailerId) {
  const trailer = state.trailers.find(t => t.id === trailerId) ||
                  state.yardTrailers.find(t => t.id === trailerId);
  if (!trailer) return;

  const location = trailer.doorNumber ? `Door ${trailer.doorNumber}` : 
                   trailer.yardSlotNumber ? `Yard Spot ${trailer.yardSlotNumber}` : 
                   'Unassigned Yard';
  
  const dwellHours = getDwellTimeHours(trailer.createdAt);
  const dwellInfo = dwellHours !== null ? `‚è±Ô∏è Dwell time: ${dwellHours} hour${dwellHours !== 1 ? 's' : ''}` : '';

  const modal = document.createElement('div');
  modal.className = 'modal active';
  modal.id = 'modal-trailer-edit';
  modal.innerHTML = `
    <div class="modal-content modal-large">
      <div class="modal-header">
        <h3>üöõ Edit Trailer</h3>
        <button class="close-modal">√ó</button>
      </div>
      <div class="trailer-edit-preview">
        ${trailer.number ? `<div class="preview-number">${trailer.number}</div>` : ''}
        <div class="preview-carrier">${trailer.carrier}</div>
        <div class="preview-location">üìç ${location}</div>
        ${dwellInfo ? `<div class="preview-dwell ${getDwellTimeClass(trailer.createdAt)}">${dwellInfo}</div>` : ''}
        <button id="btn-reset-dwell" class="btn btn-small btn-secondary" title="Reset dwell time to now">üîÑ Reset Dwell Time</button>
      </div>
      <div class="modal-body">
        <div class="trailer-edit-sections">
          <div class="edit-section">
            <div class="form-group">
              <label>Customer</label>
              <input type="text" id="edit-trailer-customer" value="${trailer.customer || ''}" placeholder="Customer name (optional)">
            </div>
            <div class="form-group carrier-autocomplete">
              <label>Carrier</label>
              <input type="text" id="edit-trailer-carrier" value="${trailer.carrier}" autocomplete="off">
              <div id="edit-carrier-suggestions" class="autocomplete-list"></div>
            </div>
            <div class="form-group">
              <label>Status</label>
              <select id="edit-trailer-status">
                <option value="loaded" ${trailer.status === 'loaded' ? 'selected' : ''}>üì¶ Loaded</option>
                <option value="empty" ${trailer.status === 'empty' ? 'selected' : ''}>üì≠ Empty</option>
              </select>
            </div>
            <div class="form-row">
              <div class="form-group half">
                <label>Trailer Number</label>
                <input type="text" id="edit-trailer-number" value="${trailer.number || ''}" placeholder="">
              </div>
              <div class="form-group half">
                <label>Load/Shipment Number</label>
                <input type="text" id="edit-trailer-loadnumber" value="${trailer.loadNumber || ''}" placeholder="Optional">
              </div>
            </div>
            <div class="form-group">
              <label>Notes</label>
              <textarea id="edit-trailer-notes" rows="2" placeholder="Optional notes...">${trailer.contents || ''}</textarea>
            </div>
          </div>
          <div class="timeline-section">
            <h4>üìú Movement Timeline</h4>
            <div id="trailer-timeline" class="timeline-container">
              <div class="timeline-loading">Loading history...</div>
            </div>
          </div>
        </div>
        <div class="modal-actions">
          <button id="btn-save-trailer" class="btn btn-primary">üíæ Save Changes</button>
          <button id="btn-delete-trailer-edit" class="btn btn-danger">üóëÔ∏è Delete Trailer</button>
          <button class="btn btn-secondary close-modal">Cancel</button>
        </div>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // Load timeline
  loadTrailerTimeline(trailerId);
  
  // Setup sanitization on all text inputs
  setupInputSanitization(document.getElementById('edit-trailer-customer'));
  setupInputSanitization(document.getElementById('edit-trailer-carrier'));
  setupInputSanitization(document.getElementById('edit-trailer-number'));
  setupInputSanitization(document.getElementById('edit-trailer-loadnumber'));
  setupInputSanitization(document.getElementById('edit-trailer-notes'));
  
  // Setup carrier autocomplete for edit modal (custom handler)
  setupEditModalCarrierAutocomplete();
  
  // Focus on customer field first
  setTimeout(() => {
    document.getElementById('edit-trailer-customer')?.focus();
  }, 100);
  
  // Close handlers
  modal.querySelectorAll('.close-modal').forEach(btn => {
    btn.addEventListener('click', () => modal.remove());
  });
  
  // Save handler - only send changed fields
  document.getElementById('btn-save-trailer')?.addEventListener('click', async () => {
    const newValues = {
      carrier: document.getElementById('edit-trailer-carrier')?.value?.trim(),
      status: document.getElementById('edit-trailer-status')?.value,
      contents: document.getElementById('edit-trailer-notes')?.value?.trim() || null,
      customer: document.getElementById('edit-trailer-customer')?.value?.trim() || null,
      loadNumber: document.getElementById('edit-trailer-loadnumber')?.value?.trim() || null,
      number: document.getElementById('edit-trailer-number')?.value?.trim()  || null
    };
    
    // Only include fields that actually changed
    const updates = {};
    
    // Compare each field with original
    if (newValues.carrier !== trailer.carrier) updates.carrier = newValues.carrier;
    if (newValues.status !== trailer.status) updates.status = newValues.status;
    if (newValues.contents !== (trailer.contents || null)) updates.contents = newValues.contents;
    if (newValues.customer !== (trailer.customer || null)) updates.customer = newValues.customer;
    if (newValues.loadNumber !== (trailer.loadNumber || null)) updates.loadNumber = newValues.loadNumber;
    if (newValues.number !== (trailer.number || null)) updates.number = newValues.number;
    
    // If nothing changed, just close the modal
    if (Object.keys(updates).length === 0) {
      modal.remove();
      return;
    }
    
    try {
      await updateTrailer(trailerId, updates);
      showToast('Trailer updated!', 'success');
      modal.remove();
      fetchState();
    } catch (error) {
      showToast(error.message, 'error');
    }
  });
  
  // Delete handler
  document.getElementById('btn-delete-trailer-edit')?.addEventListener('click', async () => {
    if (!confirm(`Delete trailer ${trailer.number || trailer.carrier}?\n\nThis cannot be undone.`)) {
      return;
    }
    try {
      await deleteTrailer(trailerId);
      showToast('Trailer deleted', 'success');
      modal.remove();
      fetchState();
    } catch (error) {
      showToast(error.message, 'error');
    }
  });
  
  // Reset dwell time handler
  document.getElementById('btn-reset-dwell')?.addEventListener('click', async () => {
    const newCreatedAt = new Date().toISOString();
    try {
      await updateTrailer(trailerId, { createdAt: newCreatedAt });
      showToast('Dwell time reset!', 'success');
      // Update the preview text
      const dwellEl = modal.querySelector('.preview-dwell');
      if (dwellEl) {
        dwellEl.textContent = '‚è±Ô∏è Dwell time: 0 hours';
        dwellEl.className = 'preview-dwell';
      }
    } catch (error) {
      showToast('Failed to reset dwell time: ' + error.message, 'error');
    }
  });
}

// ============================================================================
// Keyboard Shortcuts
// ============================================================================

function setupKeyboardShortcuts() {
  document.addEventListener('keydown', (e) => {
    // Track shift key for bulk selection
    if (e.key === 'Shift') {
      isShiftPressed = true;
    }
    
    // Ctrl+K to focus search
    if (e.ctrlKey && e.key.toLowerCase() === 'k') {
      e.preventDefault();
      const searchInput = document.getElementById('search-input');
      if (searchInput) {
        searchInput.focus();
        searchInput.select();
      }
    }
    
    // Esc to close modals
    if (e.key === 'Escape') {
      const activeModal = document.querySelector('.modal.active');
      if (activeModal && activeModal.id !== 'modal-trailer-edit' && activeModal.id !== 'modal-door-edit') {
        closeModal(activeModal.id);
      } else if (activeModal) {
        // Remove dynamically created modals
        if (activeModal.id === 'modal-trailer-edit' || activeModal.id === 'modal-door-edit' || activeModal.id === 'modal-add-door') {
          activeModal.remove();
        }
      }
      
      // Also clear selection if present
      if (selectedTrailers.size > 0) {
        clearSelection();
      }
    }
    
    // Ctrl+A to select all visible docked trailers
    if (e.ctrlKey && e.key.toLowerCase() === 'a' && !e.target.matches('input, textarea')) {
      e.preventDefault();
      const dockedTrailers = state.trailers.filter(t => t.doorNumber);
      dockedTrailers.forEach(t => selectedTrailers.add(t.id));
      updateSelectionUI();
      updateBulkActionUI();
      showToast(`Selected ${dockedTrailers.length} docked trailers`, 'info');
    }
  });
  
  document.addEventListener('keyup', (e) => {
    if (e.key === 'Shift') {
      isShiftPressed = false;
    }
  });
}

// ============================================================================
// Toast Notifications
// ============================================================================

function showToast(message, type = 'info') {
  const container = document.getElementById('toast-container');
  if (!container) return;

  const toast = document.createElement('div');
  toast.className = `toast toast-${type}`;
  toast.textContent = message;
  
  container.appendChild(toast);
  
  // Trigger animation
  requestAnimationFrame(() => {
    toast.classList.add('show');
  });
  
  // Auto remove
  setTimeout(() => {
    toast.classList.remove('show');
    setTimeout(() => toast.remove(), 300);
  }, 4000);
}

// ============================================================================
// Initialization
// ============================================================================

document.addEventListener('DOMContentLoaded', () => {
  startPolling();
  setupModals();
  setupKeyboardShortcuts();
  
  // Set up edit mode toggle with snarky warning
  document.getElementById('btn-edit-mode')?.addEventListener('click', () => {
    if (!editMode) {
      // Entering edit mode - show snarky warning
      if (!confirm(`üö® WARNING: You are about to enter EDIT MODE üö®\n\nWith great power comes great responsibility...\nand the ability to absolutely wreck everything.\n\nIn edit mode, you can:\n‚Ä¢ Delete doors (and their trailers go poof üí®)\n‚Ä¢ Wipe out carriers and all their history\n‚Ä¢ Clear analytics data (goodbye, pretty charts!)\n‚Ä¢ Rearrange the door grid into complete chaos\n‚Ä¢ Generally mess things up beyond recognition\n\nDoor numbers stay fixed, but everything else?\nFair game for your destructive tendencies.\n\nStill feeling confident? Proceed at your own risk.`)) {
        return;
      }
    }
    editMode = !editMode;
    const btn = document.getElementById('btn-edit-mode');
    if (btn) {
      btn.textContent = editMode ? '‚úÖ Done Editing' : '‚úèÔ∏è Edit Mode';
      btn.classList.toggle('btn-warning');
      btn.classList.toggle('btn-success');
    }
    renderDoors();
  });
});
